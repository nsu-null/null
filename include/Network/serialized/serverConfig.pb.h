// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: serverConfig.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_serverConfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_serverConfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_serverConfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_serverConfig_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_serverConfig_2eproto;
namespace net {
class BoxInfo;
struct BoxInfoDefaultTypeInternal;
extern BoxInfoDefaultTypeInternal _BoxInfo_default_instance_;
class ChatMessage;
struct ChatMessageDefaultTypeInternal;
extern ChatMessageDefaultTypeInternal _ChatMessage_default_instance_;
class ClientInfo;
struct ClientInfoDefaultTypeInternal;
extern ClientInfoDefaultTypeInternal _ClientInfo_default_instance_;
class ConnectRoom;
struct ConnectRoomDefaultTypeInternal;
extern ConnectRoomDefaultTypeInternal _ConnectRoom_default_instance_;
class GameMessage;
struct GameMessageDefaultTypeInternal;
extern GameMessageDefaultTypeInternal _GameMessage_default_instance_;
class GameServerConfig;
struct GameServerConfigDefaultTypeInternal;
extern GameServerConfigDefaultTypeInternal _GameServerConfig_default_instance_;
class GenerateRoom;
struct GenerateRoomDefaultTypeInternal;
extern GenerateRoomDefaultTypeInternal _GenerateRoom_default_instance_;
class NetMessage;
struct NetMessageDefaultTypeInternal;
extern NetMessageDefaultTypeInternal _NetMessage_default_instance_;
class PlayerInfo;
struct PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
}  // namespace net
PROTOBUF_NAMESPACE_OPEN
template<> ::net::BoxInfo* Arena::CreateMaybeMessage<::net::BoxInfo>(Arena*);
template<> ::net::ChatMessage* Arena::CreateMaybeMessage<::net::ChatMessage>(Arena*);
template<> ::net::ClientInfo* Arena::CreateMaybeMessage<::net::ClientInfo>(Arena*);
template<> ::net::ConnectRoom* Arena::CreateMaybeMessage<::net::ConnectRoom>(Arena*);
template<> ::net::GameMessage* Arena::CreateMaybeMessage<::net::GameMessage>(Arena*);
template<> ::net::GameServerConfig* Arena::CreateMaybeMessage<::net::GameServerConfig>(Arena*);
template<> ::net::GenerateRoom* Arena::CreateMaybeMessage<::net::GenerateRoom>(Arena*);
template<> ::net::NetMessage* Arena::CreateMaybeMessage<::net::NetMessage>(Arena*);
template<> ::net::PlayerInfo* Arena::CreateMaybeMessage<::net::PlayerInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace net {

// ===================================================================

class NetMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:net.NetMessage) */ {
 public:
  inline NetMessage() : NetMessage(nullptr) {}
  ~NetMessage() override;
  explicit constexpr NetMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetMessage(const NetMessage& from);
  NetMessage(NetMessage&& from) noexcept
    : NetMessage() {
    *this = ::std::move(from);
  }

  inline NetMessage& operator=(const NetMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetMessage& operator=(NetMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetMessage& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kServerConfig = 5,
    kClientInfo = 6,
    kGenerateRoomRequest = 7,
    kConnectRoom = 8,
    kGameMessage = 1,
    BODY_NOT_SET = 0,
  };

  static inline const NetMessage* internal_default_instance() {
    return reinterpret_cast<const NetMessage*>(
               &_NetMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NetMessage& a, NetMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(NetMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NetMessage* New() const final {
    return new NetMessage();
  }

  NetMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NetMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NetMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "net.NetMessage";
  }
  protected:
  explicit NetMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerConfigFieldNumber = 5,
    kClientInfoFieldNumber = 6,
    kGenerateRoomRequestFieldNumber = 7,
    kConnectRoomFieldNumber = 8,
    kGameMessageFieldNumber = 1,
  };
  // .net.GameServerConfig server_config = 5;
  bool has_server_config() const;
  private:
  bool _internal_has_server_config() const;
  public:
  void clear_server_config();
  const ::net::GameServerConfig& server_config() const;
  PROTOBUF_MUST_USE_RESULT ::net::GameServerConfig* release_server_config();
  ::net::GameServerConfig* mutable_server_config();
  void set_allocated_server_config(::net::GameServerConfig* server_config);
  private:
  const ::net::GameServerConfig& _internal_server_config() const;
  ::net::GameServerConfig* _internal_mutable_server_config();
  public:
  void unsafe_arena_set_allocated_server_config(
      ::net::GameServerConfig* server_config);
  ::net::GameServerConfig* unsafe_arena_release_server_config();

  // .net.ClientInfo client_info = 6;
  bool has_client_info() const;
  private:
  bool _internal_has_client_info() const;
  public:
  void clear_client_info();
  const ::net::ClientInfo& client_info() const;
  PROTOBUF_MUST_USE_RESULT ::net::ClientInfo* release_client_info();
  ::net::ClientInfo* mutable_client_info();
  void set_allocated_client_info(::net::ClientInfo* client_info);
  private:
  const ::net::ClientInfo& _internal_client_info() const;
  ::net::ClientInfo* _internal_mutable_client_info();
  public:
  void unsafe_arena_set_allocated_client_info(
      ::net::ClientInfo* client_info);
  ::net::ClientInfo* unsafe_arena_release_client_info();

  // .net.GenerateRoom generate_room_request = 7;
  bool has_generate_room_request() const;
  private:
  bool _internal_has_generate_room_request() const;
  public:
  void clear_generate_room_request();
  const ::net::GenerateRoom& generate_room_request() const;
  PROTOBUF_MUST_USE_RESULT ::net::GenerateRoom* release_generate_room_request();
  ::net::GenerateRoom* mutable_generate_room_request();
  void set_allocated_generate_room_request(::net::GenerateRoom* generate_room_request);
  private:
  const ::net::GenerateRoom& _internal_generate_room_request() const;
  ::net::GenerateRoom* _internal_mutable_generate_room_request();
  public:
  void unsafe_arena_set_allocated_generate_room_request(
      ::net::GenerateRoom* generate_room_request);
  ::net::GenerateRoom* unsafe_arena_release_generate_room_request();

  // .net.ConnectRoom connect_room = 8;
  bool has_connect_room() const;
  private:
  bool _internal_has_connect_room() const;
  public:
  void clear_connect_room();
  const ::net::ConnectRoom& connect_room() const;
  PROTOBUF_MUST_USE_RESULT ::net::ConnectRoom* release_connect_room();
  ::net::ConnectRoom* mutable_connect_room();
  void set_allocated_connect_room(::net::ConnectRoom* connect_room);
  private:
  const ::net::ConnectRoom& _internal_connect_room() const;
  ::net::ConnectRoom* _internal_mutable_connect_room();
  public:
  void unsafe_arena_set_allocated_connect_room(
      ::net::ConnectRoom* connect_room);
  ::net::ConnectRoom* unsafe_arena_release_connect_room();

  // .net.GameMessage game_message = 1;
  bool has_game_message() const;
  private:
  bool _internal_has_game_message() const;
  public:
  void clear_game_message();
  const ::net::GameMessage& game_message() const;
  PROTOBUF_MUST_USE_RESULT ::net::GameMessage* release_game_message();
  ::net::GameMessage* mutable_game_message();
  void set_allocated_game_message(::net::GameMessage* game_message);
  private:
  const ::net::GameMessage& _internal_game_message() const;
  ::net::GameMessage* _internal_mutable_game_message();
  public:
  void unsafe_arena_set_allocated_game_message(
      ::net::GameMessage* game_message);
  ::net::GameMessage* unsafe_arena_release_game_message();

  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:net.NetMessage)
 private:
  class _Internal;
  void set_has_server_config();
  void set_has_client_info();
  void set_has_generate_room_request();
  void set_has_connect_room();
  void set_has_game_message();

  inline bool has_body() const;
  inline void clear_has_body();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union BodyUnion {
    constexpr BodyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::net::GameServerConfig* server_config_;
    ::net::ClientInfo* client_info_;
    ::net::GenerateRoom* generate_room_request_;
    ::net::ConnectRoom* connect_room_;
    ::net::GameMessage* game_message_;
  } body_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_serverConfig_2eproto;
};
// -------------------------------------------------------------------

class GameServerConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:net.GameServerConfig) */ {
 public:
  inline GameServerConfig() : GameServerConfig(nullptr) {}
  ~GameServerConfig() override;
  explicit constexpr GameServerConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameServerConfig(const GameServerConfig& from);
  GameServerConfig(GameServerConfig&& from) noexcept
    : GameServerConfig() {
    *this = ::std::move(from);
  }

  inline GameServerConfig& operator=(const GameServerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameServerConfig& operator=(GameServerConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameServerConfig& default_instance() {
    return *internal_default_instance();
  }
  enum ServerAddressCase {
    kV4 = 1,
    kV6 = 2,
    SERVER_ADDRESS_NOT_SET = 0,
  };

  static inline const GameServerConfig* internal_default_instance() {
    return reinterpret_cast<const GameServerConfig*>(
               &_GameServerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GameServerConfig& a, GameServerConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(GameServerConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameServerConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameServerConfig* New() const final {
    return new GameServerConfig();
  }

  GameServerConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameServerConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameServerConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameServerConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameServerConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "net.GameServerConfig";
  }
  protected:
  explicit GameServerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomCodeFieldNumber = 5,
    kServerPortFieldNumber = 3,
    kV4FieldNumber = 1,
    kV6FieldNumber = 2,
  };
  // string room_code = 5;
  void clear_room_code();
  const std::string& room_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_code();
  PROTOBUF_MUST_USE_RESULT std::string* release_room_code();
  void set_allocated_room_code(std::string* room_code);
  private:
  const std::string& _internal_room_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_code(const std::string& value);
  std::string* _internal_mutable_room_code();
  public:

  // uint32 server_port = 3;
  void clear_server_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 server_port() const;
  void set_server_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_server_port() const;
  void _internal_set_server_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // fixed32 v4 = 1;
  bool has_v4() const;
  private:
  bool _internal_has_v4() const;
  public:
  void clear_v4();
  ::PROTOBUF_NAMESPACE_ID::uint32 v4() const;
  void set_v4(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_v4() const;
  void _internal_set_v4(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bytes v6 = 2;
  bool has_v6() const;
  private:
  bool _internal_has_v6() const;
  public:
  void clear_v6();
  const std::string& v6() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_v6(ArgT0&& arg0, ArgT... args);
  std::string* mutable_v6();
  PROTOBUF_MUST_USE_RESULT std::string* release_v6();
  void set_allocated_v6(std::string* v6);
  private:
  const std::string& _internal_v6() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v6(const std::string& value);
  std::string* _internal_mutable_v6();
  public:

  void clear_server_address();
  ServerAddressCase server_address_case() const;
  // @@protoc_insertion_point(class_scope:net.GameServerConfig)
 private:
  class _Internal;
  void set_has_v4();
  void set_has_v6();

  inline bool has_server_address() const;
  inline void clear_has_server_address();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_code_;
  ::PROTOBUF_NAMESPACE_ID::uint32 server_port_;
  union ServerAddressUnion {
    constexpr ServerAddressUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::uint32 v4_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v6_;
  } server_address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_serverConfig_2eproto;
};
// -------------------------------------------------------------------

class ClientInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:net.ClientInfo) */ {
 public:
  inline ClientInfo() : ClientInfo(nullptr) {}
  ~ClientInfo() override;
  explicit constexpr ClientInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientInfo(const ClientInfo& from);
  ClientInfo(ClientInfo&& from) noexcept
    : ClientInfo() {
    *this = ::std::move(from);
  }

  inline ClientInfo& operator=(const ClientInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientInfo& operator=(ClientInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientInfo* internal_default_instance() {
    return reinterpret_cast<const ClientInfo*>(
               &_ClientInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ClientInfo& a, ClientInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientInfo* New() const final {
    return new ClientInfo();
  }

  ClientInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClientInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "net.ClientInfo";
  }
  protected:
  explicit ClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 1,
  };
  // string client_name = 1;
  void clear_client_name();
  const std::string& client_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_client_name();
  void set_allocated_client_name(std::string* client_name);
  private:
  const std::string& _internal_client_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_name(const std::string& value);
  std::string* _internal_mutable_client_name();
  public:

  // @@protoc_insertion_point(class_scope:net.ClientInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_serverConfig_2eproto;
};
// -------------------------------------------------------------------

class GenerateRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:net.GenerateRoom) */ {
 public:
  inline GenerateRoom() : GenerateRoom(nullptr) {}
  ~GenerateRoom() override;
  explicit constexpr GenerateRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenerateRoom(const GenerateRoom& from);
  GenerateRoom(GenerateRoom&& from) noexcept
    : GenerateRoom() {
    *this = ::std::move(from);
  }

  inline GenerateRoom& operator=(const GenerateRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateRoom& operator=(GenerateRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateRoom* internal_default_instance() {
    return reinterpret_cast<const GenerateRoom*>(
               &_GenerateRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GenerateRoom& a, GenerateRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(GenerateRoom* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenerateRoom* New() const final {
    return new GenerateRoom();
  }

  GenerateRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenerateRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenerateRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GenerateRoom& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenerateRoom* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "net.GenerateRoom";
  }
  protected:
  explicit GenerateRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:net.GenerateRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_serverConfig_2eproto;
};
// -------------------------------------------------------------------

class ConnectRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:net.ConnectRoom) */ {
 public:
  inline ConnectRoom() : ConnectRoom(nullptr) {}
  ~ConnectRoom() override;
  explicit constexpr ConnectRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectRoom(const ConnectRoom& from);
  ConnectRoom(ConnectRoom&& from) noexcept
    : ConnectRoom() {
    *this = ::std::move(from);
  }

  inline ConnectRoom& operator=(const ConnectRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectRoom& operator=(ConnectRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectRoom* internal_default_instance() {
    return reinterpret_cast<const ConnectRoom*>(
               &_ConnectRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ConnectRoom& a, ConnectRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectRoom* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConnectRoom* New() const final {
    return new ConnectRoom();
  }

  ConnectRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConnectRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConnectRoom& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectRoom* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "net.ConnectRoom";
  }
  protected:
  explicit ConnectRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomCodeFieldNumber = 4,
  };
  // string room_code = 4;
  void clear_room_code();
  const std::string& room_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_code();
  PROTOBUF_MUST_USE_RESULT std::string* release_room_code();
  void set_allocated_room_code(std::string* room_code);
  private:
  const std::string& _internal_room_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_code(const std::string& value);
  std::string* _internal_mutable_room_code();
  public:

  // @@protoc_insertion_point(class_scope:net.ConnectRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_serverConfig_2eproto;
};
// -------------------------------------------------------------------

class GameMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:net.GameMessage) */ {
 public:
  inline GameMessage() : GameMessage(nullptr) {}
  ~GameMessage() override;
  explicit constexpr GameMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameMessage(const GameMessage& from);
  GameMessage(GameMessage&& from) noexcept
    : GameMessage() {
    *this = ::std::move(from);
  }

  inline GameMessage& operator=(const GameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage& operator=(GameMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kChatMessage = 2,
    kPlayerInfo = 3,
    kBoxInfo = 4,
    MESSAGE_NOT_SET = 0,
  };

  static inline const GameMessage* internal_default_instance() {
    return reinterpret_cast<const GameMessage*>(
               &_GameMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GameMessage& a, GameMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameMessage* New() const final {
    return new GameMessage();
  }

  GameMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "net.GameMessage";
  }
  protected:
  explicit GameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 5,
    kChatMessageFieldNumber = 2,
    kPlayerInfoFieldNumber = 3,
    kBoxInfoFieldNumber = 4,
  };
  // uint32 game_id = 5;
  void clear_game_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 game_id() const;
  void set_game_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_game_id() const;
  void _internal_set_game_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .net.ChatMessage chat_message = 2;
  bool has_chat_message() const;
  private:
  bool _internal_has_chat_message() const;
  public:
  void clear_chat_message();
  const ::net::ChatMessage& chat_message() const;
  PROTOBUF_MUST_USE_RESULT ::net::ChatMessage* release_chat_message();
  ::net::ChatMessage* mutable_chat_message();
  void set_allocated_chat_message(::net::ChatMessage* chat_message);
  private:
  const ::net::ChatMessage& _internal_chat_message() const;
  ::net::ChatMessage* _internal_mutable_chat_message();
  public:
  void unsafe_arena_set_allocated_chat_message(
      ::net::ChatMessage* chat_message);
  ::net::ChatMessage* unsafe_arena_release_chat_message();

  // .net.PlayerInfo player_info = 3;
  bool has_player_info() const;
  private:
  bool _internal_has_player_info() const;
  public:
  void clear_player_info();
  const ::net::PlayerInfo& player_info() const;
  PROTOBUF_MUST_USE_RESULT ::net::PlayerInfo* release_player_info();
  ::net::PlayerInfo* mutable_player_info();
  void set_allocated_player_info(::net::PlayerInfo* player_info);
  private:
  const ::net::PlayerInfo& _internal_player_info() const;
  ::net::PlayerInfo* _internal_mutable_player_info();
  public:
  void unsafe_arena_set_allocated_player_info(
      ::net::PlayerInfo* player_info);
  ::net::PlayerInfo* unsafe_arena_release_player_info();

  // .net.BoxInfo boxInfo = 4;
  bool has_boxinfo() const;
  private:
  bool _internal_has_boxinfo() const;
  public:
  void clear_boxinfo();
  const ::net::BoxInfo& boxinfo() const;
  PROTOBUF_MUST_USE_RESULT ::net::BoxInfo* release_boxinfo();
  ::net::BoxInfo* mutable_boxinfo();
  void set_allocated_boxinfo(::net::BoxInfo* boxinfo);
  private:
  const ::net::BoxInfo& _internal_boxinfo() const;
  ::net::BoxInfo* _internal_mutable_boxinfo();
  public:
  void unsafe_arena_set_allocated_boxinfo(
      ::net::BoxInfo* boxinfo);
  ::net::BoxInfo* unsafe_arena_release_boxinfo();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:net.GameMessage)
 private:
  class _Internal;
  void set_has_chat_message();
  void set_has_player_info();
  void set_has_boxinfo();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 game_id_;
  union MessageUnion {
    constexpr MessageUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::net::ChatMessage* chat_message_;
    ::net::PlayerInfo* player_info_;
    ::net::BoxInfo* boxinfo_;
  } message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_serverConfig_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:net.PlayerInfo) */ {
 public:
  inline PlayerInfo() : PlayerInfo(nullptr) {}
  ~PlayerInfo() override;
  explicit constexpr PlayerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerInfo(const PlayerInfo& from);
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerInfo* New() const final {
    return new PlayerInfo();
  }

  PlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "net.PlayerInfo";
  }
  protected:
  explicit PlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrAnimFieldNumber = 3,
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kCurrFrameFieldNumber = 4,
  };
  // string currAnim = 3;
  void clear_curranim();
  const std::string& curranim() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_curranim(ArgT0&& arg0, ArgT... args);
  std::string* mutable_curranim();
  PROTOBUF_MUST_USE_RESULT std::string* release_curranim();
  void set_allocated_curranim(std::string* curranim);
  private:
  const std::string& _internal_curranim() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_curranim(const std::string& value);
  std::string* _internal_mutable_curranim();
  public:

  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // int32 currFrame = 4;
  void clear_currframe();
  ::PROTOBUF_NAMESPACE_ID::int32 currframe() const;
  void set_currframe(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_currframe() const;
  void _internal_set_currframe(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:net.PlayerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr curranim_;
  float x_;
  float y_;
  ::PROTOBUF_NAMESPACE_ID::int32 currframe_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_serverConfig_2eproto;
};
// -------------------------------------------------------------------

class BoxInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:net.BoxInfo) */ {
 public:
  inline BoxInfo() : BoxInfo(nullptr) {}
  ~BoxInfo() override;
  explicit constexpr BoxInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoxInfo(const BoxInfo& from);
  BoxInfo(BoxInfo&& from) noexcept
    : BoxInfo() {
    *this = ::std::move(from);
  }

  inline BoxInfo& operator=(const BoxInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoxInfo& operator=(BoxInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoxInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoxInfo* internal_default_instance() {
    return reinterpret_cast<const BoxInfo*>(
               &_BoxInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BoxInfo& a, BoxInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BoxInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoxInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BoxInfo* New() const final {
    return new BoxInfo();
  }

  BoxInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BoxInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoxInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BoxInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoxInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "net.BoxInfo";
  }
  protected:
  explicit BoxInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMeowFieldNumber = 1,
  };
  // int32 meow = 1;
  void clear_meow();
  ::PROTOBUF_NAMESPACE_ID::int32 meow() const;
  void set_meow(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_meow() const;
  void _internal_set_meow(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:net.BoxInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 meow_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_serverConfig_2eproto;
};
// -------------------------------------------------------------------

class ChatMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:net.ChatMessage) */ {
 public:
  inline ChatMessage() : ChatMessage(nullptr) {}
  ~ChatMessage() override;
  explicit constexpr ChatMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatMessage(const ChatMessage& from);
  ChatMessage(ChatMessage&& from) noexcept
    : ChatMessage() {
    *this = ::std::move(from);
  }

  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatMessage& operator=(ChatMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatMessage* internal_default_instance() {
    return reinterpret_cast<const ChatMessage*>(
               &_ChatMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ChatMessage& a, ChatMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChatMessage* New() const final {
    return new ChatMessage();
  }

  ChatMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChatMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChatMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "net.ChatMessage";
  }
  protected:
  explicit ChatMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kGameIdFieldNumber = 5,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // uint32 game_id = 5;
  void clear_game_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 game_id() const;
  void set_game_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_game_id() const;
  void _internal_set_game_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:net.ChatMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::uint32 game_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_serverConfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NetMessage

// .net.GameServerConfig server_config = 5;
inline bool NetMessage::_internal_has_server_config() const {
  return body_case() == kServerConfig;
}
inline bool NetMessage::has_server_config() const {
  return _internal_has_server_config();
}
inline void NetMessage::set_has_server_config() {
  _oneof_case_[0] = kServerConfig;
}
inline void NetMessage::clear_server_config() {
  if (_internal_has_server_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete body_.server_config_;
    }
    clear_has_body();
  }
}
inline ::net::GameServerConfig* NetMessage::release_server_config() {
  // @@protoc_insertion_point(field_release:net.NetMessage.server_config)
  if (_internal_has_server_config()) {
    clear_has_body();
      ::net::GameServerConfig* temp = body_.server_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    body_.server_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::net::GameServerConfig& NetMessage::_internal_server_config() const {
  return _internal_has_server_config()
      ? *body_.server_config_
      : reinterpret_cast< ::net::GameServerConfig&>(::net::_GameServerConfig_default_instance_);
}
inline const ::net::GameServerConfig& NetMessage::server_config() const {
  // @@protoc_insertion_point(field_get:net.NetMessage.server_config)
  return _internal_server_config();
}
inline ::net::GameServerConfig* NetMessage::unsafe_arena_release_server_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:net.NetMessage.server_config)
  if (_internal_has_server_config()) {
    clear_has_body();
    ::net::GameServerConfig* temp = body_.server_config_;
    body_.server_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NetMessage::unsafe_arena_set_allocated_server_config(::net::GameServerConfig* server_config) {
  clear_body();
  if (server_config) {
    set_has_server_config();
    body_.server_config_ = server_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.NetMessage.server_config)
}
inline ::net::GameServerConfig* NetMessage::_internal_mutable_server_config() {
  if (!_internal_has_server_config()) {
    clear_body();
    set_has_server_config();
    body_.server_config_ = CreateMaybeMessage< ::net::GameServerConfig >(GetArenaForAllocation());
  }
  return body_.server_config_;
}
inline ::net::GameServerConfig* NetMessage::mutable_server_config() {
  ::net::GameServerConfig* _msg = _internal_mutable_server_config();
  // @@protoc_insertion_point(field_mutable:net.NetMessage.server_config)
  return _msg;
}

// .net.ClientInfo client_info = 6;
inline bool NetMessage::_internal_has_client_info() const {
  return body_case() == kClientInfo;
}
inline bool NetMessage::has_client_info() const {
  return _internal_has_client_info();
}
inline void NetMessage::set_has_client_info() {
  _oneof_case_[0] = kClientInfo;
}
inline void NetMessage::clear_client_info() {
  if (_internal_has_client_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete body_.client_info_;
    }
    clear_has_body();
  }
}
inline ::net::ClientInfo* NetMessage::release_client_info() {
  // @@protoc_insertion_point(field_release:net.NetMessage.client_info)
  if (_internal_has_client_info()) {
    clear_has_body();
      ::net::ClientInfo* temp = body_.client_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    body_.client_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::net::ClientInfo& NetMessage::_internal_client_info() const {
  return _internal_has_client_info()
      ? *body_.client_info_
      : reinterpret_cast< ::net::ClientInfo&>(::net::_ClientInfo_default_instance_);
}
inline const ::net::ClientInfo& NetMessage::client_info() const {
  // @@protoc_insertion_point(field_get:net.NetMessage.client_info)
  return _internal_client_info();
}
inline ::net::ClientInfo* NetMessage::unsafe_arena_release_client_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:net.NetMessage.client_info)
  if (_internal_has_client_info()) {
    clear_has_body();
    ::net::ClientInfo* temp = body_.client_info_;
    body_.client_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NetMessage::unsafe_arena_set_allocated_client_info(::net::ClientInfo* client_info) {
  clear_body();
  if (client_info) {
    set_has_client_info();
    body_.client_info_ = client_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.NetMessage.client_info)
}
inline ::net::ClientInfo* NetMessage::_internal_mutable_client_info() {
  if (!_internal_has_client_info()) {
    clear_body();
    set_has_client_info();
    body_.client_info_ = CreateMaybeMessage< ::net::ClientInfo >(GetArenaForAllocation());
  }
  return body_.client_info_;
}
inline ::net::ClientInfo* NetMessage::mutable_client_info() {
  ::net::ClientInfo* _msg = _internal_mutable_client_info();
  // @@protoc_insertion_point(field_mutable:net.NetMessage.client_info)
  return _msg;
}

// .net.GenerateRoom generate_room_request = 7;
inline bool NetMessage::_internal_has_generate_room_request() const {
  return body_case() == kGenerateRoomRequest;
}
inline bool NetMessage::has_generate_room_request() const {
  return _internal_has_generate_room_request();
}
inline void NetMessage::set_has_generate_room_request() {
  _oneof_case_[0] = kGenerateRoomRequest;
}
inline void NetMessage::clear_generate_room_request() {
  if (_internal_has_generate_room_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete body_.generate_room_request_;
    }
    clear_has_body();
  }
}
inline ::net::GenerateRoom* NetMessage::release_generate_room_request() {
  // @@protoc_insertion_point(field_release:net.NetMessage.generate_room_request)
  if (_internal_has_generate_room_request()) {
    clear_has_body();
      ::net::GenerateRoom* temp = body_.generate_room_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    body_.generate_room_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::net::GenerateRoom& NetMessage::_internal_generate_room_request() const {
  return _internal_has_generate_room_request()
      ? *body_.generate_room_request_
      : reinterpret_cast< ::net::GenerateRoom&>(::net::_GenerateRoom_default_instance_);
}
inline const ::net::GenerateRoom& NetMessage::generate_room_request() const {
  // @@protoc_insertion_point(field_get:net.NetMessage.generate_room_request)
  return _internal_generate_room_request();
}
inline ::net::GenerateRoom* NetMessage::unsafe_arena_release_generate_room_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:net.NetMessage.generate_room_request)
  if (_internal_has_generate_room_request()) {
    clear_has_body();
    ::net::GenerateRoom* temp = body_.generate_room_request_;
    body_.generate_room_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NetMessage::unsafe_arena_set_allocated_generate_room_request(::net::GenerateRoom* generate_room_request) {
  clear_body();
  if (generate_room_request) {
    set_has_generate_room_request();
    body_.generate_room_request_ = generate_room_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.NetMessage.generate_room_request)
}
inline ::net::GenerateRoom* NetMessage::_internal_mutable_generate_room_request() {
  if (!_internal_has_generate_room_request()) {
    clear_body();
    set_has_generate_room_request();
    body_.generate_room_request_ = CreateMaybeMessage< ::net::GenerateRoom >(GetArenaForAllocation());
  }
  return body_.generate_room_request_;
}
inline ::net::GenerateRoom* NetMessage::mutable_generate_room_request() {
  ::net::GenerateRoom* _msg = _internal_mutable_generate_room_request();
  // @@protoc_insertion_point(field_mutable:net.NetMessage.generate_room_request)
  return _msg;
}

// .net.ConnectRoom connect_room = 8;
inline bool NetMessage::_internal_has_connect_room() const {
  return body_case() == kConnectRoom;
}
inline bool NetMessage::has_connect_room() const {
  return _internal_has_connect_room();
}
inline void NetMessage::set_has_connect_room() {
  _oneof_case_[0] = kConnectRoom;
}
inline void NetMessage::clear_connect_room() {
  if (_internal_has_connect_room()) {
    if (GetArenaForAllocation() == nullptr) {
      delete body_.connect_room_;
    }
    clear_has_body();
  }
}
inline ::net::ConnectRoom* NetMessage::release_connect_room() {
  // @@protoc_insertion_point(field_release:net.NetMessage.connect_room)
  if (_internal_has_connect_room()) {
    clear_has_body();
      ::net::ConnectRoom* temp = body_.connect_room_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    body_.connect_room_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::net::ConnectRoom& NetMessage::_internal_connect_room() const {
  return _internal_has_connect_room()
      ? *body_.connect_room_
      : reinterpret_cast< ::net::ConnectRoom&>(::net::_ConnectRoom_default_instance_);
}
inline const ::net::ConnectRoom& NetMessage::connect_room() const {
  // @@protoc_insertion_point(field_get:net.NetMessage.connect_room)
  return _internal_connect_room();
}
inline ::net::ConnectRoom* NetMessage::unsafe_arena_release_connect_room() {
  // @@protoc_insertion_point(field_unsafe_arena_release:net.NetMessage.connect_room)
  if (_internal_has_connect_room()) {
    clear_has_body();
    ::net::ConnectRoom* temp = body_.connect_room_;
    body_.connect_room_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NetMessage::unsafe_arena_set_allocated_connect_room(::net::ConnectRoom* connect_room) {
  clear_body();
  if (connect_room) {
    set_has_connect_room();
    body_.connect_room_ = connect_room;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.NetMessage.connect_room)
}
inline ::net::ConnectRoom* NetMessage::_internal_mutable_connect_room() {
  if (!_internal_has_connect_room()) {
    clear_body();
    set_has_connect_room();
    body_.connect_room_ = CreateMaybeMessage< ::net::ConnectRoom >(GetArenaForAllocation());
  }
  return body_.connect_room_;
}
inline ::net::ConnectRoom* NetMessage::mutable_connect_room() {
  ::net::ConnectRoom* _msg = _internal_mutable_connect_room();
  // @@protoc_insertion_point(field_mutable:net.NetMessage.connect_room)
  return _msg;
}

// .net.GameMessage game_message = 1;
inline bool NetMessage::_internal_has_game_message() const {
  return body_case() == kGameMessage;
}
inline bool NetMessage::has_game_message() const {
  return _internal_has_game_message();
}
inline void NetMessage::set_has_game_message() {
  _oneof_case_[0] = kGameMessage;
}
inline void NetMessage::clear_game_message() {
  if (_internal_has_game_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete body_.game_message_;
    }
    clear_has_body();
  }
}
inline ::net::GameMessage* NetMessage::release_game_message() {
  // @@protoc_insertion_point(field_release:net.NetMessage.game_message)
  if (_internal_has_game_message()) {
    clear_has_body();
      ::net::GameMessage* temp = body_.game_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    body_.game_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::net::GameMessage& NetMessage::_internal_game_message() const {
  return _internal_has_game_message()
      ? *body_.game_message_
      : reinterpret_cast< ::net::GameMessage&>(::net::_GameMessage_default_instance_);
}
inline const ::net::GameMessage& NetMessage::game_message() const {
  // @@protoc_insertion_point(field_get:net.NetMessage.game_message)
  return _internal_game_message();
}
inline ::net::GameMessage* NetMessage::unsafe_arena_release_game_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:net.NetMessage.game_message)
  if (_internal_has_game_message()) {
    clear_has_body();
    ::net::GameMessage* temp = body_.game_message_;
    body_.game_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NetMessage::unsafe_arena_set_allocated_game_message(::net::GameMessage* game_message) {
  clear_body();
  if (game_message) {
    set_has_game_message();
    body_.game_message_ = game_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.NetMessage.game_message)
}
inline ::net::GameMessage* NetMessage::_internal_mutable_game_message() {
  if (!_internal_has_game_message()) {
    clear_body();
    set_has_game_message();
    body_.game_message_ = CreateMaybeMessage< ::net::GameMessage >(GetArenaForAllocation());
  }
  return body_.game_message_;
}
inline ::net::GameMessage* NetMessage::mutable_game_message() {
  ::net::GameMessage* _msg = _internal_mutable_game_message();
  // @@protoc_insertion_point(field_mutable:net.NetMessage.game_message)
  return _msg;
}

inline bool NetMessage::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void NetMessage::clear_has_body() {
  _oneof_case_[0] = BODY_NOT_SET;
}
inline NetMessage::BodyCase NetMessage::body_case() const {
  return NetMessage::BodyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GameServerConfig

// fixed32 v4 = 1;
inline bool GameServerConfig::_internal_has_v4() const {
  return server_address_case() == kV4;
}
inline bool GameServerConfig::has_v4() const {
  return _internal_has_v4();
}
inline void GameServerConfig::set_has_v4() {
  _oneof_case_[0] = kV4;
}
inline void GameServerConfig::clear_v4() {
  if (_internal_has_v4()) {
    server_address_.v4_ = 0u;
    clear_has_server_address();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GameServerConfig::_internal_v4() const {
  if (_internal_has_v4()) {
    return server_address_.v4_;
  }
  return 0u;
}
inline void GameServerConfig::_internal_set_v4(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  if (!_internal_has_v4()) {
    clear_server_address();
    set_has_v4();
  }
  server_address_.v4_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GameServerConfig::v4() const {
  // @@protoc_insertion_point(field_get:net.GameServerConfig.v4)
  return _internal_v4();
}
inline void GameServerConfig::set_v4(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_v4(value);
  // @@protoc_insertion_point(field_set:net.GameServerConfig.v4)
}

// bytes v6 = 2;
inline bool GameServerConfig::_internal_has_v6() const {
  return server_address_case() == kV6;
}
inline bool GameServerConfig::has_v6() const {
  return _internal_has_v6();
}
inline void GameServerConfig::set_has_v6() {
  _oneof_case_[0] = kV6;
}
inline void GameServerConfig::clear_v6() {
  if (_internal_has_v6()) {
    server_address_.v6_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_server_address();
  }
}
inline const std::string& GameServerConfig::v6() const {
  // @@protoc_insertion_point(field_get:net.GameServerConfig.v6)
  return _internal_v6();
}
template <typename ArgT0, typename... ArgT>
inline void GameServerConfig::set_v6(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_v6()) {
    clear_server_address();
    set_has_v6();
    server_address_.v6_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  server_address_.v6_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net.GameServerConfig.v6)
}
inline std::string* GameServerConfig::mutable_v6() {
  std::string* _s = _internal_mutable_v6();
  // @@protoc_insertion_point(field_mutable:net.GameServerConfig.v6)
  return _s;
}
inline const std::string& GameServerConfig::_internal_v6() const {
  if (_internal_has_v6()) {
    return server_address_.v6_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GameServerConfig::_internal_set_v6(const std::string& value) {
  if (!_internal_has_v6()) {
    clear_server_address();
    set_has_v6();
    server_address_.v6_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  server_address_.v6_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameServerConfig::_internal_mutable_v6() {
  if (!_internal_has_v6()) {
    clear_server_address();
    set_has_v6();
    server_address_.v6_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return server_address_.v6_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameServerConfig::release_v6() {
  // @@protoc_insertion_point(field_release:net.GameServerConfig.v6)
  if (_internal_has_v6()) {
    clear_has_server_address();
    return server_address_.v6_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void GameServerConfig::set_allocated_v6(std::string* v6) {
  if (has_server_address()) {
    clear_server_address();
  }
  if (v6 != nullptr) {
    set_has_v6();
    server_address_.v6_.UnsafeSetDefault(v6);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(v6);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:net.GameServerConfig.v6)
}

// uint32 server_port = 3;
inline void GameServerConfig::clear_server_port() {
  server_port_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GameServerConfig::_internal_server_port() const {
  return server_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GameServerConfig::server_port() const {
  // @@protoc_insertion_point(field_get:net.GameServerConfig.server_port)
  return _internal_server_port();
}
inline void GameServerConfig::_internal_set_server_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  server_port_ = value;
}
inline void GameServerConfig::set_server_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_server_port(value);
  // @@protoc_insertion_point(field_set:net.GameServerConfig.server_port)
}

// string room_code = 5;
inline void GameServerConfig::clear_room_code() {
  room_code_.ClearToEmpty();
}
inline const std::string& GameServerConfig::room_code() const {
  // @@protoc_insertion_point(field_get:net.GameServerConfig.room_code)
  return _internal_room_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameServerConfig::set_room_code(ArgT0&& arg0, ArgT... args) {
 
 room_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net.GameServerConfig.room_code)
}
inline std::string* GameServerConfig::mutable_room_code() {
  std::string* _s = _internal_mutable_room_code();
  // @@protoc_insertion_point(field_mutable:net.GameServerConfig.room_code)
  return _s;
}
inline const std::string& GameServerConfig::_internal_room_code() const {
  return room_code_.Get();
}
inline void GameServerConfig::_internal_set_room_code(const std::string& value) {
  
  room_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameServerConfig::_internal_mutable_room_code() {
  
  return room_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameServerConfig::release_room_code() {
  // @@protoc_insertion_point(field_release:net.GameServerConfig.room_code)
  return room_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameServerConfig::set_allocated_room_code(std::string* room_code) {
  if (room_code != nullptr) {
    
  } else {
    
  }
  room_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), room_code,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:net.GameServerConfig.room_code)
}

inline bool GameServerConfig::has_server_address() const {
  return server_address_case() != SERVER_ADDRESS_NOT_SET;
}
inline void GameServerConfig::clear_has_server_address() {
  _oneof_case_[0] = SERVER_ADDRESS_NOT_SET;
}
inline GameServerConfig::ServerAddressCase GameServerConfig::server_address_case() const {
  return GameServerConfig::ServerAddressCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientInfo

// string client_name = 1;
inline void ClientInfo::clear_client_name() {
  client_name_.ClearToEmpty();
}
inline const std::string& ClientInfo::client_name() const {
  // @@protoc_insertion_point(field_get:net.ClientInfo.client_name)
  return _internal_client_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientInfo::set_client_name(ArgT0&& arg0, ArgT... args) {
 
 client_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net.ClientInfo.client_name)
}
inline std::string* ClientInfo::mutable_client_name() {
  std::string* _s = _internal_mutable_client_name();
  // @@protoc_insertion_point(field_mutable:net.ClientInfo.client_name)
  return _s;
}
inline const std::string& ClientInfo::_internal_client_name() const {
  return client_name_.Get();
}
inline void ClientInfo::_internal_set_client_name(const std::string& value) {
  
  client_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClientInfo::_internal_mutable_client_name() {
  
  return client_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClientInfo::release_client_name() {
  // @@protoc_insertion_point(field_release:net.ClientInfo.client_name)
  return client_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClientInfo::set_allocated_client_name(std::string* client_name) {
  if (client_name != nullptr) {
    
  } else {
    
  }
  client_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:net.ClientInfo.client_name)
}

// -------------------------------------------------------------------

// GenerateRoom

// -------------------------------------------------------------------

// ConnectRoom

// string room_code = 4;
inline void ConnectRoom::clear_room_code() {
  room_code_.ClearToEmpty();
}
inline const std::string& ConnectRoom::room_code() const {
  // @@protoc_insertion_point(field_get:net.ConnectRoom.room_code)
  return _internal_room_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectRoom::set_room_code(ArgT0&& arg0, ArgT... args) {
 
 room_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net.ConnectRoom.room_code)
}
inline std::string* ConnectRoom::mutable_room_code() {
  std::string* _s = _internal_mutable_room_code();
  // @@protoc_insertion_point(field_mutable:net.ConnectRoom.room_code)
  return _s;
}
inline const std::string& ConnectRoom::_internal_room_code() const {
  return room_code_.Get();
}
inline void ConnectRoom::_internal_set_room_code(const std::string& value) {
  
  room_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConnectRoom::_internal_mutable_room_code() {
  
  return room_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConnectRoom::release_room_code() {
  // @@protoc_insertion_point(field_release:net.ConnectRoom.room_code)
  return room_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConnectRoom::set_allocated_room_code(std::string* room_code) {
  if (room_code != nullptr) {
    
  } else {
    
  }
  room_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), room_code,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:net.ConnectRoom.room_code)
}

// -------------------------------------------------------------------

// GameMessage

// uint32 game_id = 5;
inline void GameMessage::clear_game_id() {
  game_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GameMessage::_internal_game_id() const {
  return game_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GameMessage::game_id() const {
  // @@protoc_insertion_point(field_get:net.GameMessage.game_id)
  return _internal_game_id();
}
inline void GameMessage::_internal_set_game_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  game_id_ = value;
}
inline void GameMessage::set_game_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_game_id(value);
  // @@protoc_insertion_point(field_set:net.GameMessage.game_id)
}

// .net.ChatMessage chat_message = 2;
inline bool GameMessage::_internal_has_chat_message() const {
  return message_case() == kChatMessage;
}
inline bool GameMessage::has_chat_message() const {
  return _internal_has_chat_message();
}
inline void GameMessage::set_has_chat_message() {
  _oneof_case_[0] = kChatMessage;
}
inline void GameMessage::clear_chat_message() {
  if (_internal_has_chat_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.chat_message_;
    }
    clear_has_message();
  }
}
inline ::net::ChatMessage* GameMessage::release_chat_message() {
  // @@protoc_insertion_point(field_release:net.GameMessage.chat_message)
  if (_internal_has_chat_message()) {
    clear_has_message();
      ::net::ChatMessage* temp = message_.chat_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.chat_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::net::ChatMessage& GameMessage::_internal_chat_message() const {
  return _internal_has_chat_message()
      ? *message_.chat_message_
      : reinterpret_cast< ::net::ChatMessage&>(::net::_ChatMessage_default_instance_);
}
inline const ::net::ChatMessage& GameMessage::chat_message() const {
  // @@protoc_insertion_point(field_get:net.GameMessage.chat_message)
  return _internal_chat_message();
}
inline ::net::ChatMessage* GameMessage::unsafe_arena_release_chat_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:net.GameMessage.chat_message)
  if (_internal_has_chat_message()) {
    clear_has_message();
    ::net::ChatMessage* temp = message_.chat_message_;
    message_.chat_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_chat_message(::net::ChatMessage* chat_message) {
  clear_message();
  if (chat_message) {
    set_has_chat_message();
    message_.chat_message_ = chat_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.GameMessage.chat_message)
}
inline ::net::ChatMessage* GameMessage::_internal_mutable_chat_message() {
  if (!_internal_has_chat_message()) {
    clear_message();
    set_has_chat_message();
    message_.chat_message_ = CreateMaybeMessage< ::net::ChatMessage >(GetArenaForAllocation());
  }
  return message_.chat_message_;
}
inline ::net::ChatMessage* GameMessage::mutable_chat_message() {
  ::net::ChatMessage* _msg = _internal_mutable_chat_message();
  // @@protoc_insertion_point(field_mutable:net.GameMessage.chat_message)
  return _msg;
}

// .net.PlayerInfo player_info = 3;
inline bool GameMessage::_internal_has_player_info() const {
  return message_case() == kPlayerInfo;
}
inline bool GameMessage::has_player_info() const {
  return _internal_has_player_info();
}
inline void GameMessage::set_has_player_info() {
  _oneof_case_[0] = kPlayerInfo;
}
inline void GameMessage::clear_player_info() {
  if (_internal_has_player_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.player_info_;
    }
    clear_has_message();
  }
}
inline ::net::PlayerInfo* GameMessage::release_player_info() {
  // @@protoc_insertion_point(field_release:net.GameMessage.player_info)
  if (_internal_has_player_info()) {
    clear_has_message();
      ::net::PlayerInfo* temp = message_.player_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.player_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::net::PlayerInfo& GameMessage::_internal_player_info() const {
  return _internal_has_player_info()
      ? *message_.player_info_
      : reinterpret_cast< ::net::PlayerInfo&>(::net::_PlayerInfo_default_instance_);
}
inline const ::net::PlayerInfo& GameMessage::player_info() const {
  // @@protoc_insertion_point(field_get:net.GameMessage.player_info)
  return _internal_player_info();
}
inline ::net::PlayerInfo* GameMessage::unsafe_arena_release_player_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:net.GameMessage.player_info)
  if (_internal_has_player_info()) {
    clear_has_message();
    ::net::PlayerInfo* temp = message_.player_info_;
    message_.player_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_player_info(::net::PlayerInfo* player_info) {
  clear_message();
  if (player_info) {
    set_has_player_info();
    message_.player_info_ = player_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.GameMessage.player_info)
}
inline ::net::PlayerInfo* GameMessage::_internal_mutable_player_info() {
  if (!_internal_has_player_info()) {
    clear_message();
    set_has_player_info();
    message_.player_info_ = CreateMaybeMessage< ::net::PlayerInfo >(GetArenaForAllocation());
  }
  return message_.player_info_;
}
inline ::net::PlayerInfo* GameMessage::mutable_player_info() {
  ::net::PlayerInfo* _msg = _internal_mutable_player_info();
  // @@protoc_insertion_point(field_mutable:net.GameMessage.player_info)
  return _msg;
}

// .net.BoxInfo boxInfo = 4;
inline bool GameMessage::_internal_has_boxinfo() const {
  return message_case() == kBoxInfo;
}
inline bool GameMessage::has_boxinfo() const {
  return _internal_has_boxinfo();
}
inline void GameMessage::set_has_boxinfo() {
  _oneof_case_[0] = kBoxInfo;
}
inline void GameMessage::clear_boxinfo() {
  if (_internal_has_boxinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.boxinfo_;
    }
    clear_has_message();
  }
}
inline ::net::BoxInfo* GameMessage::release_boxinfo() {
  // @@protoc_insertion_point(field_release:net.GameMessage.boxInfo)
  if (_internal_has_boxinfo()) {
    clear_has_message();
      ::net::BoxInfo* temp = message_.boxinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.boxinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::net::BoxInfo& GameMessage::_internal_boxinfo() const {
  return _internal_has_boxinfo()
      ? *message_.boxinfo_
      : reinterpret_cast< ::net::BoxInfo&>(::net::_BoxInfo_default_instance_);
}
inline const ::net::BoxInfo& GameMessage::boxinfo() const {
  // @@protoc_insertion_point(field_get:net.GameMessage.boxInfo)
  return _internal_boxinfo();
}
inline ::net::BoxInfo* GameMessage::unsafe_arena_release_boxinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:net.GameMessage.boxInfo)
  if (_internal_has_boxinfo()) {
    clear_has_message();
    ::net::BoxInfo* temp = message_.boxinfo_;
    message_.boxinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_boxinfo(::net::BoxInfo* boxinfo) {
  clear_message();
  if (boxinfo) {
    set_has_boxinfo();
    message_.boxinfo_ = boxinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.GameMessage.boxInfo)
}
inline ::net::BoxInfo* GameMessage::_internal_mutable_boxinfo() {
  if (!_internal_has_boxinfo()) {
    clear_message();
    set_has_boxinfo();
    message_.boxinfo_ = CreateMaybeMessage< ::net::BoxInfo >(GetArenaForAllocation());
  }
  return message_.boxinfo_;
}
inline ::net::BoxInfo* GameMessage::mutable_boxinfo() {
  ::net::BoxInfo* _msg = _internal_mutable_boxinfo();
  // @@protoc_insertion_point(field_mutable:net.GameMessage.boxInfo)
  return _msg;
}

inline bool GameMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void GameMessage::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline GameMessage::MessageCase GameMessage::message_case() const {
  return GameMessage::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PlayerInfo

// float x = 1;
inline void PlayerInfo::clear_x() {
  x_ = 0;
}
inline float PlayerInfo::_internal_x() const {
  return x_;
}
inline float PlayerInfo::x() const {
  // @@protoc_insertion_point(field_get:net.PlayerInfo.x)
  return _internal_x();
}
inline void PlayerInfo::_internal_set_x(float value) {
  
  x_ = value;
}
inline void PlayerInfo::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:net.PlayerInfo.x)
}

// float y = 2;
inline void PlayerInfo::clear_y() {
  y_ = 0;
}
inline float PlayerInfo::_internal_y() const {
  return y_;
}
inline float PlayerInfo::y() const {
  // @@protoc_insertion_point(field_get:net.PlayerInfo.y)
  return _internal_y();
}
inline void PlayerInfo::_internal_set_y(float value) {
  
  y_ = value;
}
inline void PlayerInfo::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:net.PlayerInfo.y)
}

// string currAnim = 3;
inline void PlayerInfo::clear_curranim() {
  curranim_.ClearToEmpty();
}
inline const std::string& PlayerInfo::curranim() const {
  // @@protoc_insertion_point(field_get:net.PlayerInfo.currAnim)
  return _internal_curranim();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerInfo::set_curranim(ArgT0&& arg0, ArgT... args) {
 
 curranim_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net.PlayerInfo.currAnim)
}
inline std::string* PlayerInfo::mutable_curranim() {
  std::string* _s = _internal_mutable_curranim();
  // @@protoc_insertion_point(field_mutable:net.PlayerInfo.currAnim)
  return _s;
}
inline const std::string& PlayerInfo::_internal_curranim() const {
  return curranim_.Get();
}
inline void PlayerInfo::_internal_set_curranim(const std::string& value) {
  
  curranim_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlayerInfo::_internal_mutable_curranim() {
  
  return curranim_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlayerInfo::release_curranim() {
  // @@protoc_insertion_point(field_release:net.PlayerInfo.currAnim)
  return curranim_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PlayerInfo::set_allocated_curranim(std::string* curranim) {
  if (curranim != nullptr) {
    
  } else {
    
  }
  curranim_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), curranim,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:net.PlayerInfo.currAnim)
}

// int32 currFrame = 4;
inline void PlayerInfo::clear_currframe() {
  currframe_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfo::_internal_currframe() const {
  return currframe_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfo::currframe() const {
  // @@protoc_insertion_point(field_get:net.PlayerInfo.currFrame)
  return _internal_currframe();
}
inline void PlayerInfo::_internal_set_currframe(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  currframe_ = value;
}
inline void PlayerInfo::set_currframe(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_currframe(value);
  // @@protoc_insertion_point(field_set:net.PlayerInfo.currFrame)
}

// -------------------------------------------------------------------

// BoxInfo

// int32 meow = 1;
inline void BoxInfo::clear_meow() {
  meow_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BoxInfo::_internal_meow() const {
  return meow_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BoxInfo::meow() const {
  // @@protoc_insertion_point(field_get:net.BoxInfo.meow)
  return _internal_meow();
}
inline void BoxInfo::_internal_set_meow(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  meow_ = value;
}
inline void BoxInfo::set_meow(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_meow(value);
  // @@protoc_insertion_point(field_set:net.BoxInfo.meow)
}

// -------------------------------------------------------------------

// ChatMessage

// uint32 game_id = 5;
inline void ChatMessage::clear_game_id() {
  game_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChatMessage::_internal_game_id() const {
  return game_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChatMessage::game_id() const {
  // @@protoc_insertion_point(field_get:net.ChatMessage.game_id)
  return _internal_game_id();
}
inline void ChatMessage::_internal_set_game_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  game_id_ = value;
}
inline void ChatMessage::set_game_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_game_id(value);
  // @@protoc_insertion_point(field_set:net.ChatMessage.game_id)
}

// string message = 1;
inline void ChatMessage::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& ChatMessage::message() const {
  // @@protoc_insertion_point(field_get:net.ChatMessage.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net.ChatMessage.message)
}
inline std::string* ChatMessage::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:net.ChatMessage.message)
  return _s;
}
inline const std::string& ChatMessage::_internal_message() const {
  return message_.Get();
}
inline void ChatMessage::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChatMessage::release_message() {
  // @@protoc_insertion_point(field_release:net.ChatMessage.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChatMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:net.ChatMessage.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace net

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_serverConfig_2eproto
