// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scene.proto

#include "scene.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace serial {
constexpr Scene::Scene(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : box2d_position_(nullptr){}
struct SceneDefaultTypeInternal {
  constexpr SceneDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SceneDefaultTypeInternal() {}
  union {
    Scene _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SceneDefaultTypeInternal _Scene_default_instance_;
constexpr GameObject::GameObject(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct GameObjectDefaultTypeInternal {
  constexpr GameObjectDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GameObjectDefaultTypeInternal() {}
  union {
    GameObject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GameObjectDefaultTypeInternal _GameObject_default_instance_;
constexpr Script::Script(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct ScriptDefaultTypeInternal {
  constexpr ScriptDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ScriptDefaultTypeInternal() {}
  union {
    Script _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ScriptDefaultTypeInternal _Script_default_instance_;
constexpr BasicScript::BasicScript(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct BasicScriptDefaultTypeInternal {
  constexpr BasicScriptDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BasicScriptDefaultTypeInternal() {}
  union {
    BasicScript _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BasicScriptDefaultTypeInternal _BasicScript_default_instance_;
constexpr BasicGameObject::BasicGameObject(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : children_objects_()
  , children_scripts_()
  , tags_()
  , sprite_(nullptr)
  , visible_(false)
  , box2d_type_(0)

  , render_layer_(0)
{}
struct BasicGameObjectDefaultTypeInternal {
  constexpr BasicGameObjectDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BasicGameObjectDefaultTypeInternal() {}
  union {
    BasicGameObject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BasicGameObjectDefaultTypeInternal _BasicGameObject_default_instance_;
constexpr Position::Position(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : x_(0)
  , y_(0){}
struct PositionDefaultTypeInternal {
  constexpr PositionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PositionDefaultTypeInternal() {}
  union {
    Position _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PositionDefaultTypeInternal _Position_default_instance_;
constexpr Sprite_Scale::Sprite_Scale(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : scale_x_(0)
  , scale_y_(0){}
struct Sprite_ScaleDefaultTypeInternal {
  constexpr Sprite_ScaleDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Sprite_ScaleDefaultTypeInternal() {}
  union {
    Sprite_Scale _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Sprite_ScaleDefaultTypeInternal _Sprite_Scale_default_instance_;
constexpr Sprite::Sprite(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : texture_path_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , position_(nullptr)
  , scale_(nullptr){}
struct SpriteDefaultTypeInternal {
  constexpr SpriteDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SpriteDefaultTypeInternal() {}
  union {
    Sprite _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SpriteDefaultTypeInternal _Sprite_default_instance_;
}  // namespace serial
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_scene_2eproto[8];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_scene_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_scene_2eproto = nullptr;

const uint32_t TableStruct_scene_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serial::Scene, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serial::Scene, box2d_position_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serial::GameObject, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::serial::GameObject, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::serial::GameObject, game_object_instance_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serial::Script, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::serial::Script, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::serial::Script, script_instance_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serial::BasicScript, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serial::BasicGameObject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serial::BasicGameObject, children_objects_),
  PROTOBUF_FIELD_OFFSET(::serial::BasicGameObject, children_scripts_),
  PROTOBUF_FIELD_OFFSET(::serial::BasicGameObject, tags_),
  PROTOBUF_FIELD_OFFSET(::serial::BasicGameObject, render_layer_),
  PROTOBUF_FIELD_OFFSET(::serial::BasicGameObject, sprite_),
  PROTOBUF_FIELD_OFFSET(::serial::BasicGameObject, visible_),
  PROTOBUF_FIELD_OFFSET(::serial::BasicGameObject, box2d_type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serial::Position, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serial::Position, x_),
  PROTOBUF_FIELD_OFFSET(::serial::Position, y_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serial::Sprite_Scale, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serial::Sprite_Scale, scale_x_),
  PROTOBUF_FIELD_OFFSET(::serial::Sprite_Scale, scale_y_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serial::Sprite, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serial::Sprite, texture_path_),
  PROTOBUF_FIELD_OFFSET(::serial::Sprite, position_),
  PROTOBUF_FIELD_OFFSET(::serial::Sprite, scale_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::serial::Scene)},
  { 7, -1, -1, sizeof(::serial::GameObject)},
  { 15, -1, -1, sizeof(::serial::Script)},
  { 23, -1, -1, sizeof(::serial::BasicScript)},
  { 29, -1, -1, sizeof(::serial::BasicGameObject)},
  { 42, -1, -1, sizeof(::serial::Position)},
  { 50, -1, -1, sizeof(::serial::Sprite_Scale)},
  { 58, -1, -1, sizeof(::serial::Sprite)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serial::_Scene_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serial::_GameObject_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serial::_Script_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serial::_BasicScript_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serial::_BasicGameObject_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serial::_Position_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serial::_Sprite_Scale_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serial::_Sprite_default_instance_),
};

const char descriptor_table_protodef_scene_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\013scene.proto\022\006serial\"1\n\005Scene\022(\n\016box2d_"
  "position\030\002 \001(\0132\020.serial.Position\"Z\n\nGame"
  "Object\0224\n\021basic_game_object\030\001 \001(\0132\027.seri"
  "al.BasicGameObjectH\000B\026\n\024game_object_inst"
  "ance\"H\n\006Script\022+\n\014basic_script\030\001 \001(\0132\023.s"
  "erial.BasicScriptH\000B\021\n\017script_instance\"\r"
  "\n\013BasicScript\"\372\001\n\017BasicGameObject\022,\n\020chi"
  "ldren_objects\030\001 \003(\0132\022.serial.GameObject\022"
  "(\n\020children_scripts\030\002 \003(\0132\016.serial.Scrip"
  "t\022\014\n\004tags\030\003 \003(\t\022)\n\014render_layer\030\007 \001(\0162\023."
  "serial.RenderLayer\022\036\n\006sprite\030\004 \001(\0132\016.ser"
  "ial.Sprite\022\017\n\007visible\030\005 \001(\010\022%\n\nbox2d_typ"
  "e\030\006 \001(\0162\021.serial.Box2DType\" \n\010Position\022\t"
  "\n\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\"\222\001\n\006Sprite\022\024\n\014textu"
  "re_path\030\001 \001(\t\022\"\n\010position\030\002 \001(\0132\020.serial"
  ".Position\022#\n\005scale\030\005 \001(\0132\024.serial.Sprite"
  ".Scale\032)\n\005Scale\022\017\n\007scale_x\030\001 \001(\002\022\017\n\007scal"
  "e_y\030\002 \001(\002*\236\001\n\013RenderLayer\022\016\n\nBACKGROUND\020"
  "\000\022\017\n\013BACKGROUND1\020\001\022\017\n\013BACKGROUND2\020\002\022\017\n\013B"
  "ACKGROUND3\020\003\022\016\n\nFOREGROUND\020\004\022\017\n\013FOREGROU"
  "ND1\020\005\022\017\n\013FOREGROUND2\020\006\022\017\n\013FOREGROUND3\020\007\022"
  "\t\n\005ONTOP\020\010*$\n\tBox2DType\022\n\n\006STATIC\020\000\022\013\n\007D"
  "YNAMIC\020\001b\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_scene_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_scene_2eproto = {
  false, false, 896, descriptor_table_protodef_scene_2eproto, "scene.proto", 
  &descriptor_table_scene_2eproto_once, nullptr, 0, 8,
  schemas, file_default_instances, TableStruct_scene_2eproto::offsets,
  file_level_metadata_scene_2eproto, file_level_enum_descriptors_scene_2eproto, file_level_service_descriptors_scene_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_scene_2eproto_getter() {
  return &descriptor_table_scene_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_scene_2eproto(&descriptor_table_scene_2eproto);
namespace serial {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RenderLayer_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_scene_2eproto);
  return file_level_enum_descriptors_scene_2eproto[0];
}
bool RenderLayer_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Box2DType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_scene_2eproto);
  return file_level_enum_descriptors_scene_2eproto[1];
}
bool Box2DType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Scene::_Internal {
 public:
  static const ::serial::Position& box2d_position(const Scene* msg);
};

const ::serial::Position&
Scene::_Internal::box2d_position(const Scene* msg) {
  return *msg->box2d_position_;
}
Scene::Scene(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serial.Scene)
}
Scene::Scene(const Scene& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_box2d_position()) {
    box2d_position_ = new ::serial::Position(*from.box2d_position_);
  } else {
    box2d_position_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:serial.Scene)
}

inline void Scene::SharedCtor() {
box2d_position_ = nullptr;
}

Scene::~Scene() {
  // @@protoc_insertion_point(destructor:serial.Scene)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Scene::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete box2d_position_;
}

void Scene::ArenaDtor(void* object) {
  Scene* _this = reinterpret_cast< Scene* >(object);
  (void)_this;
}
void Scene::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Scene::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Scene::Clear() {
// @@protoc_insertion_point(message_clear_start:serial.Scene)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && box2d_position_ != nullptr) {
    delete box2d_position_;
  }
  box2d_position_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Scene::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .serial.Position box2d_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_box2d_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Scene::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serial.Scene)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .serial.Position box2d_position = 2;
  if (this->_internal_has_box2d_position()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::box2d_position(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serial.Scene)
  return target;
}

size_t Scene::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serial.Scene)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .serial.Position box2d_position = 2;
  if (this->_internal_has_box2d_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *box2d_position_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Scene::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Scene::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Scene::GetClassData() const { return &_class_data_; }

void Scene::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Scene *>(to)->MergeFrom(
      static_cast<const Scene &>(from));
}


void Scene::MergeFrom(const Scene& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serial.Scene)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_box2d_position()) {
    _internal_mutable_box2d_position()->::serial::Position::MergeFrom(from._internal_box2d_position());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Scene::CopyFrom(const Scene& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serial.Scene)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Scene::IsInitialized() const {
  return true;
}

void Scene::InternalSwap(Scene* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(box2d_position_, other->box2d_position_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Scene::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scene_2eproto_getter, &descriptor_table_scene_2eproto_once,
      file_level_metadata_scene_2eproto[0]);
}

// ===================================================================

class GameObject::_Internal {
 public:
  static const ::serial::BasicGameObject& basic_game_object(const GameObject* msg);
};

const ::serial::BasicGameObject&
GameObject::_Internal::basic_game_object(const GameObject* msg) {
  return *msg->game_object_instance_.basic_game_object_;
}
void GameObject::set_allocated_basic_game_object(::serial::BasicGameObject* basic_game_object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_game_object_instance();
  if (basic_game_object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::serial::BasicGameObject>::GetOwningArena(basic_game_object);
    if (message_arena != submessage_arena) {
      basic_game_object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, basic_game_object, submessage_arena);
    }
    set_has_basic_game_object();
    game_object_instance_.basic_game_object_ = basic_game_object;
  }
  // @@protoc_insertion_point(field_set_allocated:serial.GameObject.basic_game_object)
}
GameObject::GameObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serial.GameObject)
}
GameObject::GameObject(const GameObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_game_object_instance();
  switch (from.game_object_instance_case()) {
    case kBasicGameObject: {
      _internal_mutable_basic_game_object()->::serial::BasicGameObject::MergeFrom(from._internal_basic_game_object());
      break;
    }
    case GAME_OBJECT_INSTANCE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:serial.GameObject)
}

inline void GameObject::SharedCtor() {
clear_has_game_object_instance();
}

GameObject::~GameObject() {
  // @@protoc_insertion_point(destructor:serial.GameObject)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GameObject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_game_object_instance()) {
    clear_game_object_instance();
  }
}

void GameObject::ArenaDtor(void* object) {
  GameObject* _this = reinterpret_cast< GameObject* >(object);
  (void)_this;
}
void GameObject::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GameObject::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GameObject::clear_game_object_instance() {
// @@protoc_insertion_point(one_of_clear_start:serial.GameObject)
  switch (game_object_instance_case()) {
    case kBasicGameObject: {
      if (GetArenaForAllocation() == nullptr) {
        delete game_object_instance_.basic_game_object_;
      }
      break;
    }
    case GAME_OBJECT_INSTANCE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = GAME_OBJECT_INSTANCE_NOT_SET;
}


void GameObject::Clear() {
// @@protoc_insertion_point(message_clear_start:serial.GameObject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_game_object_instance();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameObject::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .serial.BasicGameObject basic_game_object = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_basic_game_object(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameObject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serial.GameObject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .serial.BasicGameObject basic_game_object = 1;
  if (_internal_has_basic_game_object()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::basic_game_object(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serial.GameObject)
  return target;
}

size_t GameObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serial.GameObject)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (game_object_instance_case()) {
    // .serial.BasicGameObject basic_game_object = 1;
    case kBasicGameObject: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *game_object_instance_.basic_game_object_);
      break;
    }
    case GAME_OBJECT_INSTANCE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameObject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GameObject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameObject::GetClassData() const { return &_class_data_; }

void GameObject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GameObject *>(to)->MergeFrom(
      static_cast<const GameObject &>(from));
}


void GameObject::MergeFrom(const GameObject& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serial.GameObject)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.game_object_instance_case()) {
    case kBasicGameObject: {
      _internal_mutable_basic_game_object()->::serial::BasicGameObject::MergeFrom(from._internal_basic_game_object());
      break;
    }
    case GAME_OBJECT_INSTANCE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameObject::CopyFrom(const GameObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serial.GameObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameObject::IsInitialized() const {
  return true;
}

void GameObject::InternalSwap(GameObject* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(game_object_instance_, other->game_object_instance_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata GameObject::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scene_2eproto_getter, &descriptor_table_scene_2eproto_once,
      file_level_metadata_scene_2eproto[1]);
}

// ===================================================================

class Script::_Internal {
 public:
  static const ::serial::BasicScript& basic_script(const Script* msg);
};

const ::serial::BasicScript&
Script::_Internal::basic_script(const Script* msg) {
  return *msg->script_instance_.basic_script_;
}
void Script::set_allocated_basic_script(::serial::BasicScript* basic_script) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_script_instance();
  if (basic_script) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::serial::BasicScript>::GetOwningArena(basic_script);
    if (message_arena != submessage_arena) {
      basic_script = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, basic_script, submessage_arena);
    }
    set_has_basic_script();
    script_instance_.basic_script_ = basic_script;
  }
  // @@protoc_insertion_point(field_set_allocated:serial.Script.basic_script)
}
Script::Script(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serial.Script)
}
Script::Script(const Script& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_script_instance();
  switch (from.script_instance_case()) {
    case kBasicScript: {
      _internal_mutable_basic_script()->::serial::BasicScript::MergeFrom(from._internal_basic_script());
      break;
    }
    case SCRIPT_INSTANCE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:serial.Script)
}

inline void Script::SharedCtor() {
clear_has_script_instance();
}

Script::~Script() {
  // @@protoc_insertion_point(destructor:serial.Script)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Script::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_script_instance()) {
    clear_script_instance();
  }
}

void Script::ArenaDtor(void* object) {
  Script* _this = reinterpret_cast< Script* >(object);
  (void)_this;
}
void Script::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Script::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Script::clear_script_instance() {
// @@protoc_insertion_point(one_of_clear_start:serial.Script)
  switch (script_instance_case()) {
    case kBasicScript: {
      if (GetArenaForAllocation() == nullptr) {
        delete script_instance_.basic_script_;
      }
      break;
    }
    case SCRIPT_INSTANCE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SCRIPT_INSTANCE_NOT_SET;
}


void Script::Clear() {
// @@protoc_insertion_point(message_clear_start:serial.Script)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_script_instance();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Script::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .serial.BasicScript basic_script = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_basic_script(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Script::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serial.Script)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .serial.BasicScript basic_script = 1;
  if (_internal_has_basic_script()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::basic_script(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serial.Script)
  return target;
}

size_t Script::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serial.Script)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (script_instance_case()) {
    // .serial.BasicScript basic_script = 1;
    case kBasicScript: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *script_instance_.basic_script_);
      break;
    }
    case SCRIPT_INSTANCE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Script::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Script::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Script::GetClassData() const { return &_class_data_; }

void Script::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Script *>(to)->MergeFrom(
      static_cast<const Script &>(from));
}


void Script::MergeFrom(const Script& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serial.Script)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.script_instance_case()) {
    case kBasicScript: {
      _internal_mutable_basic_script()->::serial::BasicScript::MergeFrom(from._internal_basic_script());
      break;
    }
    case SCRIPT_INSTANCE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Script::CopyFrom(const Script& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serial.Script)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Script::IsInitialized() const {
  return true;
}

void Script::InternalSwap(Script* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(script_instance_, other->script_instance_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Script::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scene_2eproto_getter, &descriptor_table_scene_2eproto_once,
      file_level_metadata_scene_2eproto[2]);
}

// ===================================================================

class BasicScript::_Internal {
 public:
};

BasicScript::BasicScript(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:serial.BasicScript)
}
BasicScript::BasicScript(const BasicScript& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:serial.BasicScript)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BasicScript::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BasicScript::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata BasicScript::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scene_2eproto_getter, &descriptor_table_scene_2eproto_once,
      file_level_metadata_scene_2eproto[3]);
}

// ===================================================================

class BasicGameObject::_Internal {
 public:
  static const ::serial::Sprite& sprite(const BasicGameObject* msg);
};

const ::serial::Sprite&
BasicGameObject::_Internal::sprite(const BasicGameObject* msg) {
  return *msg->sprite_;
}
BasicGameObject::BasicGameObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  children_objects_(arena),
  children_scripts_(arena),
  tags_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serial.BasicGameObject)
}
BasicGameObject::BasicGameObject(const BasicGameObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      children_objects_(from.children_objects_),
      children_scripts_(from.children_scripts_),
      tags_(from.tags_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_sprite()) {
    sprite_ = new ::serial::Sprite(*from.sprite_);
  } else {
    sprite_ = nullptr;
  }
  ::memcpy(&visible_, &from.visible_,
    static_cast<size_t>(reinterpret_cast<char*>(&render_layer_) -
    reinterpret_cast<char*>(&visible_)) + sizeof(render_layer_));
  // @@protoc_insertion_point(copy_constructor:serial.BasicGameObject)
}

inline void BasicGameObject::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sprite_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&render_layer_) -
    reinterpret_cast<char*>(&sprite_)) + sizeof(render_layer_));
}

BasicGameObject::~BasicGameObject() {
  // @@protoc_insertion_point(destructor:serial.BasicGameObject)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BasicGameObject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete sprite_;
}

void BasicGameObject::ArenaDtor(void* object) {
  BasicGameObject* _this = reinterpret_cast< BasicGameObject* >(object);
  (void)_this;
}
void BasicGameObject::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BasicGameObject::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BasicGameObject::Clear() {
// @@protoc_insertion_point(message_clear_start:serial.BasicGameObject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  children_objects_.Clear();
  children_scripts_.Clear();
  tags_.Clear();
  if (GetArenaForAllocation() == nullptr && sprite_ != nullptr) {
    delete sprite_;
  }
  sprite_ = nullptr;
  ::memset(&visible_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&render_layer_) -
      reinterpret_cast<char*>(&visible_)) + sizeof(render_layer_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BasicGameObject::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .serial.GameObject children_objects = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_children_objects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .serial.Script children_scripts = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_children_scripts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string tags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_tags();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "serial.BasicGameObject.tags"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .serial.Sprite sprite = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_sprite(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool visible = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          visible_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serial.Box2DType box2d_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_box2d_type(static_cast<::serial::Box2DType>(val));
        } else
          goto handle_unusual;
        continue;
      // .serial.RenderLayer render_layer = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_render_layer(static_cast<::serial::RenderLayer>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BasicGameObject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serial.BasicGameObject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .serial.GameObject children_objects = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_children_objects_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_children_objects(i), target, stream);
  }

  // repeated .serial.Script children_scripts = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_children_scripts_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_children_scripts(i), target, stream);
  }

  // repeated string tags = 3;
  for (int i = 0, n = this->_internal_tags_size(); i < n; i++) {
    const auto& s = this->_internal_tags(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "serial.BasicGameObject.tags");
    target = stream->WriteString(3, s, target);
  }

  // .serial.Sprite sprite = 4;
  if (this->_internal_has_sprite()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::sprite(this), target, stream);
  }

  // bool visible = 5;
  if (this->_internal_visible() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_visible(), target);
  }

  // .serial.Box2DType box2d_type = 6;
  if (this->_internal_box2d_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_box2d_type(), target);
  }

  // .serial.RenderLayer render_layer = 7;
  if (this->_internal_render_layer() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_render_layer(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serial.BasicGameObject)
  return target;
}

size_t BasicGameObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serial.BasicGameObject)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .serial.GameObject children_objects = 1;
  total_size += 1UL * this->_internal_children_objects_size();
  for (const auto& msg : this->children_objects_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .serial.Script children_scripts = 2;
  total_size += 1UL * this->_internal_children_scripts_size();
  for (const auto& msg : this->children_scripts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string tags = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(tags_.size());
  for (int i = 0, n = tags_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      tags_.Get(i));
  }

  // .serial.Sprite sprite = 4;
  if (this->_internal_has_sprite()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sprite_);
  }

  // bool visible = 5;
  if (this->_internal_visible() != 0) {
    total_size += 1 + 1;
  }

  // .serial.Box2DType box2d_type = 6;
  if (this->_internal_box2d_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_box2d_type());
  }

  // .serial.RenderLayer render_layer = 7;
  if (this->_internal_render_layer() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_render_layer());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BasicGameObject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BasicGameObject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BasicGameObject::GetClassData() const { return &_class_data_; }

void BasicGameObject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BasicGameObject *>(to)->MergeFrom(
      static_cast<const BasicGameObject &>(from));
}


void BasicGameObject::MergeFrom(const BasicGameObject& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serial.BasicGameObject)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  children_objects_.MergeFrom(from.children_objects_);
  children_scripts_.MergeFrom(from.children_scripts_);
  tags_.MergeFrom(from.tags_);
  if (from._internal_has_sprite()) {
    _internal_mutable_sprite()->::serial::Sprite::MergeFrom(from._internal_sprite());
  }
  if (from._internal_visible() != 0) {
    _internal_set_visible(from._internal_visible());
  }
  if (from._internal_box2d_type() != 0) {
    _internal_set_box2d_type(from._internal_box2d_type());
  }
  if (from._internal_render_layer() != 0) {
    _internal_set_render_layer(from._internal_render_layer());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BasicGameObject::CopyFrom(const BasicGameObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serial.BasicGameObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BasicGameObject::IsInitialized() const {
  return true;
}

void BasicGameObject::InternalSwap(BasicGameObject* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  children_objects_.InternalSwap(&other->children_objects_);
  children_scripts_.InternalSwap(&other->children_scripts_);
  tags_.InternalSwap(&other->tags_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BasicGameObject, render_layer_)
      + sizeof(BasicGameObject::render_layer_)
      - PROTOBUF_FIELD_OFFSET(BasicGameObject, sprite_)>(
          reinterpret_cast<char*>(&sprite_),
          reinterpret_cast<char*>(&other->sprite_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BasicGameObject::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scene_2eproto_getter, &descriptor_table_scene_2eproto_once,
      file_level_metadata_scene_2eproto[4]);
}

// ===================================================================

class Position::_Internal {
 public:
};

Position::Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serial.Position)
}
Position::Position(const Position& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
  // @@protoc_insertion_point(copy_constructor:serial.Position)
}

inline void Position::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
}

Position::~Position() {
  // @@protoc_insertion_point(destructor:serial.Position)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Position::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Position::ArenaDtor(void* object) {
  Position* _this = reinterpret_cast< Position* >(object);
  (void)_this;
}
void Position::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Position::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Position::Clear() {
// @@protoc_insertion_point(message_clear_start:serial.Position)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&y_) -
      reinterpret_cast<char*>(&x_)) + sizeof(y_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Position::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Position::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serial.Position)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serial.Position)
  return target;
}

size_t Position::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serial.Position)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Position::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Position::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Position::GetClassData() const { return &_class_data_; }

void Position::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Position *>(to)->MergeFrom(
      static_cast<const Position &>(from));
}


void Position::MergeFrom(const Position& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serial.Position)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _internal_set_y(from._internal_y());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Position::CopyFrom(const Position& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serial.Position)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Position::IsInitialized() const {
  return true;
}

void Position::InternalSwap(Position* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Position, y_)
      + sizeof(Position::y_)
      - PROTOBUF_FIELD_OFFSET(Position, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Position::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scene_2eproto_getter, &descriptor_table_scene_2eproto_once,
      file_level_metadata_scene_2eproto[5]);
}

// ===================================================================

class Sprite_Scale::_Internal {
 public:
};

Sprite_Scale::Sprite_Scale(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serial.Sprite.Scale)
}
Sprite_Scale::Sprite_Scale(const Sprite_Scale& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&scale_x_, &from.scale_x_,
    static_cast<size_t>(reinterpret_cast<char*>(&scale_y_) -
    reinterpret_cast<char*>(&scale_x_)) + sizeof(scale_y_));
  // @@protoc_insertion_point(copy_constructor:serial.Sprite.Scale)
}

inline void Sprite_Scale::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&scale_x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&scale_y_) -
    reinterpret_cast<char*>(&scale_x_)) + sizeof(scale_y_));
}

Sprite_Scale::~Sprite_Scale() {
  // @@protoc_insertion_point(destructor:serial.Sprite.Scale)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Sprite_Scale::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Sprite_Scale::ArenaDtor(void* object) {
  Sprite_Scale* _this = reinterpret_cast< Sprite_Scale* >(object);
  (void)_this;
}
void Sprite_Scale::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Sprite_Scale::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Sprite_Scale::Clear() {
// @@protoc_insertion_point(message_clear_start:serial.Sprite.Scale)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&scale_x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&scale_y_) -
      reinterpret_cast<char*>(&scale_x_)) + sizeof(scale_y_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Sprite_Scale::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float scale_x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          scale_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float scale_y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          scale_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Sprite_Scale::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serial.Sprite.Scale)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float scale_x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale_x = this->_internal_scale_x();
  uint32_t raw_scale_x;
  memcpy(&raw_scale_x, &tmp_scale_x, sizeof(tmp_scale_x));
  if (raw_scale_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_scale_x(), target);
  }

  // float scale_y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale_y = this->_internal_scale_y();
  uint32_t raw_scale_y;
  memcpy(&raw_scale_y, &tmp_scale_y, sizeof(tmp_scale_y));
  if (raw_scale_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_scale_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serial.Sprite.Scale)
  return target;
}

size_t Sprite_Scale::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serial.Sprite.Scale)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float scale_x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale_x = this->_internal_scale_x();
  uint32_t raw_scale_x;
  memcpy(&raw_scale_x, &tmp_scale_x, sizeof(tmp_scale_x));
  if (raw_scale_x != 0) {
    total_size += 1 + 4;
  }

  // float scale_y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale_y = this->_internal_scale_y();
  uint32_t raw_scale_y;
  memcpy(&raw_scale_y, &tmp_scale_y, sizeof(tmp_scale_y));
  if (raw_scale_y != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Sprite_Scale::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Sprite_Scale::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Sprite_Scale::GetClassData() const { return &_class_data_; }

void Sprite_Scale::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Sprite_Scale *>(to)->MergeFrom(
      static_cast<const Sprite_Scale &>(from));
}


void Sprite_Scale::MergeFrom(const Sprite_Scale& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serial.Sprite.Scale)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale_x = from._internal_scale_x();
  uint32_t raw_scale_x;
  memcpy(&raw_scale_x, &tmp_scale_x, sizeof(tmp_scale_x));
  if (raw_scale_x != 0) {
    _internal_set_scale_x(from._internal_scale_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale_y = from._internal_scale_y();
  uint32_t raw_scale_y;
  memcpy(&raw_scale_y, &tmp_scale_y, sizeof(tmp_scale_y));
  if (raw_scale_y != 0) {
    _internal_set_scale_y(from._internal_scale_y());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Sprite_Scale::CopyFrom(const Sprite_Scale& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serial.Sprite.Scale)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sprite_Scale::IsInitialized() const {
  return true;
}

void Sprite_Scale::InternalSwap(Sprite_Scale* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Sprite_Scale, scale_y_)
      + sizeof(Sprite_Scale::scale_y_)
      - PROTOBUF_FIELD_OFFSET(Sprite_Scale, scale_x_)>(
          reinterpret_cast<char*>(&scale_x_),
          reinterpret_cast<char*>(&other->scale_x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Sprite_Scale::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scene_2eproto_getter, &descriptor_table_scene_2eproto_once,
      file_level_metadata_scene_2eproto[6]);
}

// ===================================================================

class Sprite::_Internal {
 public:
  static const ::serial::Position& position(const Sprite* msg);
  static const ::serial::Sprite_Scale& scale(const Sprite* msg);
};

const ::serial::Position&
Sprite::_Internal::position(const Sprite* msg) {
  return *msg->position_;
}
const ::serial::Sprite_Scale&
Sprite::_Internal::scale(const Sprite* msg) {
  return *msg->scale_;
}
Sprite::Sprite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serial.Sprite)
}
Sprite::Sprite(const Sprite& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  texture_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    texture_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_texture_path().empty()) {
    texture_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_texture_path(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_position()) {
    position_ = new ::serial::Position(*from.position_);
  } else {
    position_ = nullptr;
  }
  if (from._internal_has_scale()) {
    scale_ = new ::serial::Sprite_Scale(*from.scale_);
  } else {
    scale_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:serial.Sprite)
}

inline void Sprite::SharedCtor() {
texture_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  texture_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&position_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&scale_) -
    reinterpret_cast<char*>(&position_)) + sizeof(scale_));
}

Sprite::~Sprite() {
  // @@protoc_insertion_point(destructor:serial.Sprite)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Sprite::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  texture_path_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete position_;
  if (this != internal_default_instance()) delete scale_;
}

void Sprite::ArenaDtor(void* object) {
  Sprite* _this = reinterpret_cast< Sprite* >(object);
  (void)_this;
}
void Sprite::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Sprite::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Sprite::Clear() {
// @@protoc_insertion_point(message_clear_start:serial.Sprite)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  texture_path_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
  if (GetArenaForAllocation() == nullptr && scale_ != nullptr) {
    delete scale_;
  }
  scale_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Sprite::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string texture_path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_texture_path();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "serial.Sprite.texture_path"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serial.Position position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serial.Sprite.Scale scale = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_scale(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Sprite::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serial.Sprite)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string texture_path = 1;
  if (!this->_internal_texture_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_texture_path().data(), static_cast<int>(this->_internal_texture_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "serial.Sprite.texture_path");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_texture_path(), target);
  }

  // .serial.Position position = 2;
  if (this->_internal_has_position()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::position(this), target, stream);
  }

  // .serial.Sprite.Scale scale = 5;
  if (this->_internal_has_scale()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::scale(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serial.Sprite)
  return target;
}

size_t Sprite::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serial.Sprite)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string texture_path = 1;
  if (!this->_internal_texture_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_texture_path());
  }

  // .serial.Position position = 2;
  if (this->_internal_has_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *position_);
  }

  // .serial.Sprite.Scale scale = 5;
  if (this->_internal_has_scale()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *scale_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Sprite::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Sprite::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Sprite::GetClassData() const { return &_class_data_; }

void Sprite::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Sprite *>(to)->MergeFrom(
      static_cast<const Sprite &>(from));
}


void Sprite::MergeFrom(const Sprite& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serial.Sprite)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_texture_path().empty()) {
    _internal_set_texture_path(from._internal_texture_path());
  }
  if (from._internal_has_position()) {
    _internal_mutable_position()->::serial::Position::MergeFrom(from._internal_position());
  }
  if (from._internal_has_scale()) {
    _internal_mutable_scale()->::serial::Sprite_Scale::MergeFrom(from._internal_scale());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Sprite::CopyFrom(const Sprite& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serial.Sprite)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sprite::IsInitialized() const {
  return true;
}

void Sprite::InternalSwap(Sprite* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &texture_path_, lhs_arena,
      &other->texture_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Sprite, scale_)
      + sizeof(Sprite::scale_)
      - PROTOBUF_FIELD_OFFSET(Sprite, position_)>(
          reinterpret_cast<char*>(&position_),
          reinterpret_cast<char*>(&other->position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Sprite::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scene_2eproto_getter, &descriptor_table_scene_2eproto_once,
      file_level_metadata_scene_2eproto[7]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace serial
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::serial::Scene* Arena::CreateMaybeMessage< ::serial::Scene >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serial::Scene >(arena);
}
template<> PROTOBUF_NOINLINE ::serial::GameObject* Arena::CreateMaybeMessage< ::serial::GameObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serial::GameObject >(arena);
}
template<> PROTOBUF_NOINLINE ::serial::Script* Arena::CreateMaybeMessage< ::serial::Script >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serial::Script >(arena);
}
template<> PROTOBUF_NOINLINE ::serial::BasicScript* Arena::CreateMaybeMessage< ::serial::BasicScript >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serial::BasicScript >(arena);
}
template<> PROTOBUF_NOINLINE ::serial::BasicGameObject* Arena::CreateMaybeMessage< ::serial::BasicGameObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serial::BasicGameObject >(arena);
}
template<> PROTOBUF_NOINLINE ::serial::Position* Arena::CreateMaybeMessage< ::serial::Position >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serial::Position >(arena);
}
template<> PROTOBUF_NOINLINE ::serial::Sprite_Scale* Arena::CreateMaybeMessage< ::serial::Sprite_Scale >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serial::Sprite_Scale >(arena);
}
template<> PROTOBUF_NOINLINE ::serial::Sprite* Arena::CreateMaybeMessage< ::serial::Sprite >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serial::Sprite >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
