// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scene.proto

#include "scene.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace serial {
constexpr Scene::Scene(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : game_object_()
  , camera_(nullptr){}
struct SceneDefaultTypeInternal {
  constexpr SceneDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SceneDefaultTypeInternal() {}
  union {
    Scene _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SceneDefaultTypeInternal _Scene_default_instance_;
constexpr Camera::Camera(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CameraDefaultTypeInternal {
  constexpr CameraDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CameraDefaultTypeInternal() {}
  union {
    Camera _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CameraDefaultTypeInternal _Camera_default_instance_;
constexpr GameObject::GameObject(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct GameObjectDefaultTypeInternal {
  constexpr GameObjectDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GameObjectDefaultTypeInternal() {}
  union {
    GameObject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GameObjectDefaultTypeInternal _GameObject_default_instance_;
constexpr Script::Script(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : go_id_(0u)
  , _oneof_case_{}{}
struct ScriptDefaultTypeInternal {
  constexpr ScriptDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ScriptDefaultTypeInternal() {}
  union {
    Script _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ScriptDefaultTypeInternal _Script_default_instance_;
constexpr BasicGameObject::BasicGameObject(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : children_objects_()
  , children_scripts_()
  , tags_()
  , sprite_(nullptr)
  , visible_(false)
  , box2d_type_(0)

  , render_layer_(0)

  , id_(0u){}
struct BasicGameObjectDefaultTypeInternal {
  constexpr BasicGameObjectDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BasicGameObjectDefaultTypeInternal() {}
  union {
    BasicGameObject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BasicGameObjectDefaultTypeInternal _BasicGameObject_default_instance_;
constexpr Sprite_Scale::Sprite_Scale(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : scale_x_(0)
  , scale_y_(0){}
struct Sprite_ScaleDefaultTypeInternal {
  constexpr Sprite_ScaleDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Sprite_ScaleDefaultTypeInternal() {}
  union {
    Sprite_Scale _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Sprite_ScaleDefaultTypeInternal _Sprite_Scale_default_instance_;
constexpr Sprite::Sprite(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : texture_path_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , position_(nullptr)
  , scale_(nullptr){}
struct SpriteDefaultTypeInternal {
  constexpr SpriteDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SpriteDefaultTypeInternal() {}
  union {
    Sprite _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SpriteDefaultTypeInternal _Sprite_default_instance_;
}  // namespace serial
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_scene_2eproto[7];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_scene_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_scene_2eproto = nullptr;

const uint32_t TableStruct_scene_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serial::Scene, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serial::Scene, game_object_),
  PROTOBUF_FIELD_OFFSET(::serial::Scene, camera_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serial::Camera, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serial::GameObject, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::serial::GameObject, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::serial::GameObject, game_object_instance_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serial::Script, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::serial::Script, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::serial::Script, go_id_),
  PROTOBUF_FIELD_OFFSET(::serial::Script, script_instance_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serial::BasicGameObject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serial::BasicGameObject, children_objects_),
  PROTOBUF_FIELD_OFFSET(::serial::BasicGameObject, children_scripts_),
  PROTOBUF_FIELD_OFFSET(::serial::BasicGameObject, tags_),
  PROTOBUF_FIELD_OFFSET(::serial::BasicGameObject, sprite_),
  PROTOBUF_FIELD_OFFSET(::serial::BasicGameObject, visible_),
  PROTOBUF_FIELD_OFFSET(::serial::BasicGameObject, box2d_type_),
  PROTOBUF_FIELD_OFFSET(::serial::BasicGameObject, render_layer_),
  PROTOBUF_FIELD_OFFSET(::serial::BasicGameObject, id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serial::Sprite_Scale, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serial::Sprite_Scale, scale_x_),
  PROTOBUF_FIELD_OFFSET(::serial::Sprite_Scale, scale_y_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serial::Sprite, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serial::Sprite, texture_path_),
  PROTOBUF_FIELD_OFFSET(::serial::Sprite, position_),
  PROTOBUF_FIELD_OFFSET(::serial::Sprite, scale_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::serial::Scene)},
  { 8, -1, -1, sizeof(::serial::Camera)},
  { 14, -1, -1, sizeof(::serial::GameObject)},
  { 22, -1, -1, sizeof(::serial::Script)},
  { 43, -1, -1, sizeof(::serial::BasicGameObject)},
  { 57, -1, -1, sizeof(::serial::Sprite_Scale)},
  { 65, -1, -1, sizeof(::serial::Sprite)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serial::_Scene_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serial::_Camera_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serial::_GameObject_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serial::_Script_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serial::_BasicGameObject_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serial::_Sprite_Scale_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serial::_Sprite_default_instance_),
};

const char descriptor_table_protodef_scene_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\013scene.proto\022\006serial\032\rscripts.proto\"P\n\005"
  "Scene\022\'\n\013game_object\030\001 \003(\0132\022.serial.Game"
  "Object\022\036\n\006camera\030\002 \001(\0132\016.serial.Camera\"\010"
  "\n\006Camera\"Z\n\nGameObject\0224\n\021basic_game_obj"
  "ect\030\001 \001(\0132\027.serial.BasicGameObjectH\000B\026\n\024"
  "game_object_instance\"\350\005\n\006Script\0223\n\020playe"
  "r_animation\030\001 \001(\0132\027.serial.PlayerAnimati"
  "onH\000\022<\n\025example_camera_script\030\002 \001(\0132\033.se"
  "rial.ExampleCameraScriptH\000\022>\n\026example_cl"
  "ocked_script\030\003 \001(\0132\034.serial.ExampleClock"
  "edScriptH\000\0228\n\023reload_scene_script\030\004 \001(\0132"
  "\031.serial.ReloadSceneScriptH\000\022-\n\rcamera_s"
  "cript\030\005 \001(\0132\024.serial.CameraScriptH\000\022-\n\rb"
  "utton_script\030\006 \001(\0132\024.serial.ButtonScript"
  "H\000\022/\n\016clocked_script\030\007 \001(\0132\025.serial.Cloc"
  "kedScriptH\000\022/\n\016example_script\030\010 \001(\0132\025.se"
  "rial.ExampleScriptH\000\022>\n\026straight_weapon_"
  "script\030\t \001(\0132\034.serial.StraightWeaponScri"
  "ptH\000\022-\n\rweapon_script\030\n \001(\0132\024.serial.Wea"
  "ponScriptH\000\022-\n\rbullet_script\030\013 \001(\0132\024.ser"
  "ial.BulletScriptH\000\022<\n\025network_player_scr"
  "ipt\030\014 \001(\0132\033.serial.NetworkPlayerScriptH\000"
  "\0223\n\020cursor_animation\030\r \001(\0132\027.serial.Curs"
  "orAnimationH\000\022\r\n\005go_id\030\016 \001(\rB\021\n\017script_i"
  "nstance\"\206\002\n\017BasicGameObject\022,\n\020children_"
  "objects\030\001 \003(\0132\022.serial.GameObject\022(\n\020chi"
  "ldren_scripts\030\002 \003(\0132\016.serial.Script\022\014\n\004t"
  "ags\030\003 \003(\t\022\036\n\006sprite\030\004 \001(\0132\016.serial.Sprit"
  "e\022\017\n\007visible\030\005 \001(\010\022%\n\nbox2d_type\030\006 \001(\0162\021"
  ".serial.Box2DType\022)\n\014render_layer\030\007 \001(\0162"
  "\023.serial.RenderLayer\022\n\n\002id\030\010 \001(\r\"\222\001\n\006Spr"
  "ite\022\024\n\014texture_path\030\001 \001(\t\022\"\n\010position\030\002 "
  "\001(\0132\020.serial.Vector2f\022#\n\005scale\030\005 \001(\0132\024.s"
  "erial.Sprite.Scale\032)\n\005Scale\022\017\n\007scale_x\030\001"
  " \001(\002\022\017\n\007scale_y\030\002 \001(\002*\236\001\n\013RenderLayer\022\016\n"
  "\nBACKGROUND\020\000\022\017\n\013BACKGROUND1\020\001\022\017\n\013BACKGR"
  "OUND2\020\002\022\017\n\013BACKGROUND3\020\003\022\016\n\nFOREGROUND\020\004"
  "\022\017\n\013FOREGROUND1\020\005\022\017\n\013FOREGROUND2\020\006\022\017\n\013FO"
  "REGROUND3\020\007\022\t\n\005ONTOP\020\010*$\n\tBox2DType\022\n\n\006S"
  "TATIC\020\000\022\013\n\007DYNAMIC\020\001b\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_scene_2eproto_deps[1] = {
  &::descriptor_table_scripts_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_scene_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_scene_2eproto = {
  false, false, 1588, descriptor_table_protodef_scene_2eproto, "scene.proto", 
  &descriptor_table_scene_2eproto_once, descriptor_table_scene_2eproto_deps, 1, 7,
  schemas, file_default_instances, TableStruct_scene_2eproto::offsets,
  file_level_metadata_scene_2eproto, file_level_enum_descriptors_scene_2eproto, file_level_service_descriptors_scene_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_scene_2eproto_getter() {
  return &descriptor_table_scene_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_scene_2eproto(&descriptor_table_scene_2eproto);
namespace serial {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RenderLayer_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_scene_2eproto);
  return file_level_enum_descriptors_scene_2eproto[0];
}
bool RenderLayer_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Box2DType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_scene_2eproto);
  return file_level_enum_descriptors_scene_2eproto[1];
}
bool Box2DType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Scene::_Internal {
 public:
  static const ::serial::Camera& camera(const Scene* msg);
};

const ::serial::Camera&
Scene::_Internal::camera(const Scene* msg) {
  return *msg->camera_;
}
Scene::Scene(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  game_object_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serial.Scene)
}
Scene::Scene(const Scene& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      game_object_(from.game_object_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_camera()) {
    camera_ = new ::serial::Camera(*from.camera_);
  } else {
    camera_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:serial.Scene)
}

inline void Scene::SharedCtor() {
camera_ = nullptr;
}

Scene::~Scene() {
  // @@protoc_insertion_point(destructor:serial.Scene)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Scene::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete camera_;
}

void Scene::ArenaDtor(void* object) {
  Scene* _this = reinterpret_cast< Scene* >(object);
  (void)_this;
}
void Scene::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Scene::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Scene::Clear() {
// @@protoc_insertion_point(message_clear_start:serial.Scene)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  game_object_.Clear();
  if (GetArenaForAllocation() == nullptr && camera_ != nullptr) {
    delete camera_;
  }
  camera_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Scene::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .serial.GameObject game_object = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_game_object(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .serial.Camera camera = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_camera(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Scene::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serial.Scene)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .serial.GameObject game_object = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_game_object_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_game_object(i), target, stream);
  }

  // .serial.Camera camera = 2;
  if (this->_internal_has_camera()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::camera(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serial.Scene)
  return target;
}

size_t Scene::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serial.Scene)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .serial.GameObject game_object = 1;
  total_size += 1UL * this->_internal_game_object_size();
  for (const auto& msg : this->game_object_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .serial.Camera camera = 2;
  if (this->_internal_has_camera()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *camera_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Scene::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Scene::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Scene::GetClassData() const { return &_class_data_; }

void Scene::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Scene *>(to)->MergeFrom(
      static_cast<const Scene &>(from));
}


void Scene::MergeFrom(const Scene& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serial.Scene)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  game_object_.MergeFrom(from.game_object_);
  if (from._internal_has_camera()) {
    _internal_mutable_camera()->::serial::Camera::MergeFrom(from._internal_camera());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Scene::CopyFrom(const Scene& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serial.Scene)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Scene::IsInitialized() const {
  return true;
}

void Scene::InternalSwap(Scene* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  game_object_.InternalSwap(&other->game_object_);
  swap(camera_, other->camera_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Scene::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scene_2eproto_getter, &descriptor_table_scene_2eproto_once,
      file_level_metadata_scene_2eproto[0]);
}

// ===================================================================

class Camera::_Internal {
 public:
};

Camera::Camera(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:serial.Camera)
}
Camera::Camera(const Camera& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:serial.Camera)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Camera::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Camera::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Camera::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scene_2eproto_getter, &descriptor_table_scene_2eproto_once,
      file_level_metadata_scene_2eproto[1]);
}

// ===================================================================

class GameObject::_Internal {
 public:
  static const ::serial::BasicGameObject& basic_game_object(const GameObject* msg);
};

const ::serial::BasicGameObject&
GameObject::_Internal::basic_game_object(const GameObject* msg) {
  return *msg->game_object_instance_.basic_game_object_;
}
void GameObject::set_allocated_basic_game_object(::serial::BasicGameObject* basic_game_object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_game_object_instance();
  if (basic_game_object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::serial::BasicGameObject>::GetOwningArena(basic_game_object);
    if (message_arena != submessage_arena) {
      basic_game_object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, basic_game_object, submessage_arena);
    }
    set_has_basic_game_object();
    game_object_instance_.basic_game_object_ = basic_game_object;
  }
  // @@protoc_insertion_point(field_set_allocated:serial.GameObject.basic_game_object)
}
GameObject::GameObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serial.GameObject)
}
GameObject::GameObject(const GameObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_game_object_instance();
  switch (from.game_object_instance_case()) {
    case kBasicGameObject: {
      _internal_mutable_basic_game_object()->::serial::BasicGameObject::MergeFrom(from._internal_basic_game_object());
      break;
    }
    case GAME_OBJECT_INSTANCE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:serial.GameObject)
}

inline void GameObject::SharedCtor() {
clear_has_game_object_instance();
}

GameObject::~GameObject() {
  // @@protoc_insertion_point(destructor:serial.GameObject)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GameObject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_game_object_instance()) {
    clear_game_object_instance();
  }
}

void GameObject::ArenaDtor(void* object) {
  GameObject* _this = reinterpret_cast< GameObject* >(object);
  (void)_this;
}
void GameObject::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GameObject::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GameObject::clear_game_object_instance() {
// @@protoc_insertion_point(one_of_clear_start:serial.GameObject)
  switch (game_object_instance_case()) {
    case kBasicGameObject: {
      if (GetArenaForAllocation() == nullptr) {
        delete game_object_instance_.basic_game_object_;
      }
      break;
    }
    case GAME_OBJECT_INSTANCE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = GAME_OBJECT_INSTANCE_NOT_SET;
}


void GameObject::Clear() {
// @@protoc_insertion_point(message_clear_start:serial.GameObject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_game_object_instance();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameObject::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .serial.BasicGameObject basic_game_object = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_basic_game_object(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameObject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serial.GameObject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .serial.BasicGameObject basic_game_object = 1;
  if (_internal_has_basic_game_object()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::basic_game_object(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serial.GameObject)
  return target;
}

size_t GameObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serial.GameObject)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (game_object_instance_case()) {
    // .serial.BasicGameObject basic_game_object = 1;
    case kBasicGameObject: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *game_object_instance_.basic_game_object_);
      break;
    }
    case GAME_OBJECT_INSTANCE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameObject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GameObject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameObject::GetClassData() const { return &_class_data_; }

void GameObject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GameObject *>(to)->MergeFrom(
      static_cast<const GameObject &>(from));
}


void GameObject::MergeFrom(const GameObject& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serial.GameObject)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.game_object_instance_case()) {
    case kBasicGameObject: {
      _internal_mutable_basic_game_object()->::serial::BasicGameObject::MergeFrom(from._internal_basic_game_object());
      break;
    }
    case GAME_OBJECT_INSTANCE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameObject::CopyFrom(const GameObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serial.GameObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameObject::IsInitialized() const {
  return true;
}

void GameObject::InternalSwap(GameObject* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(game_object_instance_, other->game_object_instance_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata GameObject::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scene_2eproto_getter, &descriptor_table_scene_2eproto_once,
      file_level_metadata_scene_2eproto[2]);
}

// ===================================================================

class Script::_Internal {
 public:
  static const ::serial::PlayerAnimation& player_animation(const Script* msg);
  static const ::serial::ExampleCameraScript& example_camera_script(const Script* msg);
  static const ::serial::ExampleClockedScript& example_clocked_script(const Script* msg);
  static const ::serial::ReloadSceneScript& reload_scene_script(const Script* msg);
  static const ::serial::CameraScript& camera_script(const Script* msg);
  static const ::serial::ButtonScript& button_script(const Script* msg);
  static const ::serial::ClockedScript& clocked_script(const Script* msg);
  static const ::serial::ExampleScript& example_script(const Script* msg);
  static const ::serial::StraightWeaponScript& straight_weapon_script(const Script* msg);
  static const ::serial::WeaponScript& weapon_script(const Script* msg);
  static const ::serial::BulletScript& bullet_script(const Script* msg);
  static const ::serial::NetworkPlayerScript& network_player_script(const Script* msg);
  static const ::serial::CursorAnimation& cursor_animation(const Script* msg);
};

const ::serial::PlayerAnimation&
Script::_Internal::player_animation(const Script* msg) {
  return *msg->script_instance_.player_animation_;
}
const ::serial::ExampleCameraScript&
Script::_Internal::example_camera_script(const Script* msg) {
  return *msg->script_instance_.example_camera_script_;
}
const ::serial::ExampleClockedScript&
Script::_Internal::example_clocked_script(const Script* msg) {
  return *msg->script_instance_.example_clocked_script_;
}
const ::serial::ReloadSceneScript&
Script::_Internal::reload_scene_script(const Script* msg) {
  return *msg->script_instance_.reload_scene_script_;
}
const ::serial::CameraScript&
Script::_Internal::camera_script(const Script* msg) {
  return *msg->script_instance_.camera_script_;
}
const ::serial::ButtonScript&
Script::_Internal::button_script(const Script* msg) {
  return *msg->script_instance_.button_script_;
}
const ::serial::ClockedScript&
Script::_Internal::clocked_script(const Script* msg) {
  return *msg->script_instance_.clocked_script_;
}
const ::serial::ExampleScript&
Script::_Internal::example_script(const Script* msg) {
  return *msg->script_instance_.example_script_;
}
const ::serial::StraightWeaponScript&
Script::_Internal::straight_weapon_script(const Script* msg) {
  return *msg->script_instance_.straight_weapon_script_;
}
const ::serial::WeaponScript&
Script::_Internal::weapon_script(const Script* msg) {
  return *msg->script_instance_.weapon_script_;
}
const ::serial::BulletScript&
Script::_Internal::bullet_script(const Script* msg) {
  return *msg->script_instance_.bullet_script_;
}
const ::serial::NetworkPlayerScript&
Script::_Internal::network_player_script(const Script* msg) {
  return *msg->script_instance_.network_player_script_;
}
const ::serial::CursorAnimation&
Script::_Internal::cursor_animation(const Script* msg) {
  return *msg->script_instance_.cursor_animation_;
}
void Script::set_allocated_player_animation(::serial::PlayerAnimation* player_animation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_script_instance();
  if (player_animation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_animation));
    if (message_arena != submessage_arena) {
      player_animation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_animation, submessage_arena);
    }
    set_has_player_animation();
    script_instance_.player_animation_ = player_animation;
  }
  // @@protoc_insertion_point(field_set_allocated:serial.Script.player_animation)
}
void Script::clear_player_animation() {
  if (_internal_has_player_animation()) {
    if (GetArenaForAllocation() == nullptr) {
      delete script_instance_.player_animation_;
    }
    clear_has_script_instance();
  }
}
void Script::set_allocated_example_camera_script(::serial::ExampleCameraScript* example_camera_script) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_script_instance();
  if (example_camera_script) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(example_camera_script));
    if (message_arena != submessage_arena) {
      example_camera_script = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, example_camera_script, submessage_arena);
    }
    set_has_example_camera_script();
    script_instance_.example_camera_script_ = example_camera_script;
  }
  // @@protoc_insertion_point(field_set_allocated:serial.Script.example_camera_script)
}
void Script::clear_example_camera_script() {
  if (_internal_has_example_camera_script()) {
    if (GetArenaForAllocation() == nullptr) {
      delete script_instance_.example_camera_script_;
    }
    clear_has_script_instance();
  }
}
void Script::set_allocated_example_clocked_script(::serial::ExampleClockedScript* example_clocked_script) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_script_instance();
  if (example_clocked_script) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(example_clocked_script));
    if (message_arena != submessage_arena) {
      example_clocked_script = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, example_clocked_script, submessage_arena);
    }
    set_has_example_clocked_script();
    script_instance_.example_clocked_script_ = example_clocked_script;
  }
  // @@protoc_insertion_point(field_set_allocated:serial.Script.example_clocked_script)
}
void Script::clear_example_clocked_script() {
  if (_internal_has_example_clocked_script()) {
    if (GetArenaForAllocation() == nullptr) {
      delete script_instance_.example_clocked_script_;
    }
    clear_has_script_instance();
  }
}
void Script::set_allocated_reload_scene_script(::serial::ReloadSceneScript* reload_scene_script) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_script_instance();
  if (reload_scene_script) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reload_scene_script));
    if (message_arena != submessage_arena) {
      reload_scene_script = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reload_scene_script, submessage_arena);
    }
    set_has_reload_scene_script();
    script_instance_.reload_scene_script_ = reload_scene_script;
  }
  // @@protoc_insertion_point(field_set_allocated:serial.Script.reload_scene_script)
}
void Script::clear_reload_scene_script() {
  if (_internal_has_reload_scene_script()) {
    if (GetArenaForAllocation() == nullptr) {
      delete script_instance_.reload_scene_script_;
    }
    clear_has_script_instance();
  }
}
void Script::set_allocated_camera_script(::serial::CameraScript* camera_script) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_script_instance();
  if (camera_script) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera_script));
    if (message_arena != submessage_arena) {
      camera_script = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_script, submessage_arena);
    }
    set_has_camera_script();
    script_instance_.camera_script_ = camera_script;
  }
  // @@protoc_insertion_point(field_set_allocated:serial.Script.camera_script)
}
void Script::clear_camera_script() {
  if (_internal_has_camera_script()) {
    if (GetArenaForAllocation() == nullptr) {
      delete script_instance_.camera_script_;
    }
    clear_has_script_instance();
  }
}
void Script::set_allocated_button_script(::serial::ButtonScript* button_script) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_script_instance();
  if (button_script) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(button_script));
    if (message_arena != submessage_arena) {
      button_script = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, button_script, submessage_arena);
    }
    set_has_button_script();
    script_instance_.button_script_ = button_script;
  }
  // @@protoc_insertion_point(field_set_allocated:serial.Script.button_script)
}
void Script::clear_button_script() {
  if (_internal_has_button_script()) {
    if (GetArenaForAllocation() == nullptr) {
      delete script_instance_.button_script_;
    }
    clear_has_script_instance();
  }
}
void Script::set_allocated_clocked_script(::serial::ClockedScript* clocked_script) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_script_instance();
  if (clocked_script) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(clocked_script));
    if (message_arena != submessage_arena) {
      clocked_script = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clocked_script, submessage_arena);
    }
    set_has_clocked_script();
    script_instance_.clocked_script_ = clocked_script;
  }
  // @@protoc_insertion_point(field_set_allocated:serial.Script.clocked_script)
}
void Script::clear_clocked_script() {
  if (_internal_has_clocked_script()) {
    if (GetArenaForAllocation() == nullptr) {
      delete script_instance_.clocked_script_;
    }
    clear_has_script_instance();
  }
}
void Script::set_allocated_example_script(::serial::ExampleScript* example_script) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_script_instance();
  if (example_script) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(example_script));
    if (message_arena != submessage_arena) {
      example_script = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, example_script, submessage_arena);
    }
    set_has_example_script();
    script_instance_.example_script_ = example_script;
  }
  // @@protoc_insertion_point(field_set_allocated:serial.Script.example_script)
}
void Script::clear_example_script() {
  if (_internal_has_example_script()) {
    if (GetArenaForAllocation() == nullptr) {
      delete script_instance_.example_script_;
    }
    clear_has_script_instance();
  }
}
void Script::set_allocated_straight_weapon_script(::serial::StraightWeaponScript* straight_weapon_script) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_script_instance();
  if (straight_weapon_script) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(straight_weapon_script));
    if (message_arena != submessage_arena) {
      straight_weapon_script = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, straight_weapon_script, submessage_arena);
    }
    set_has_straight_weapon_script();
    script_instance_.straight_weapon_script_ = straight_weapon_script;
  }
  // @@protoc_insertion_point(field_set_allocated:serial.Script.straight_weapon_script)
}
void Script::clear_straight_weapon_script() {
  if (_internal_has_straight_weapon_script()) {
    if (GetArenaForAllocation() == nullptr) {
      delete script_instance_.straight_weapon_script_;
    }
    clear_has_script_instance();
  }
}
void Script::set_allocated_weapon_script(::serial::WeaponScript* weapon_script) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_script_instance();
  if (weapon_script) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(weapon_script));
    if (message_arena != submessage_arena) {
      weapon_script = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, weapon_script, submessage_arena);
    }
    set_has_weapon_script();
    script_instance_.weapon_script_ = weapon_script;
  }
  // @@protoc_insertion_point(field_set_allocated:serial.Script.weapon_script)
}
void Script::clear_weapon_script() {
  if (_internal_has_weapon_script()) {
    if (GetArenaForAllocation() == nullptr) {
      delete script_instance_.weapon_script_;
    }
    clear_has_script_instance();
  }
}
void Script::set_allocated_bullet_script(::serial::BulletScript* bullet_script) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_script_instance();
  if (bullet_script) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bullet_script));
    if (message_arena != submessage_arena) {
      bullet_script = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bullet_script, submessage_arena);
    }
    set_has_bullet_script();
    script_instance_.bullet_script_ = bullet_script;
  }
  // @@protoc_insertion_point(field_set_allocated:serial.Script.bullet_script)
}
void Script::clear_bullet_script() {
  if (_internal_has_bullet_script()) {
    if (GetArenaForAllocation() == nullptr) {
      delete script_instance_.bullet_script_;
    }
    clear_has_script_instance();
  }
}
void Script::set_allocated_network_player_script(::serial::NetworkPlayerScript* network_player_script) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_script_instance();
  if (network_player_script) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(network_player_script));
    if (message_arena != submessage_arena) {
      network_player_script = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network_player_script, submessage_arena);
    }
    set_has_network_player_script();
    script_instance_.network_player_script_ = network_player_script;
  }
  // @@protoc_insertion_point(field_set_allocated:serial.Script.network_player_script)
}
void Script::clear_network_player_script() {
  if (_internal_has_network_player_script()) {
    if (GetArenaForAllocation() == nullptr) {
      delete script_instance_.network_player_script_;
    }
    clear_has_script_instance();
  }
}
void Script::set_allocated_cursor_animation(::serial::CursorAnimation* cursor_animation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_script_instance();
  if (cursor_animation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cursor_animation));
    if (message_arena != submessage_arena) {
      cursor_animation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cursor_animation, submessage_arena);
    }
    set_has_cursor_animation();
    script_instance_.cursor_animation_ = cursor_animation;
  }
  // @@protoc_insertion_point(field_set_allocated:serial.Script.cursor_animation)
}
void Script::clear_cursor_animation() {
  if (_internal_has_cursor_animation()) {
    if (GetArenaForAllocation() == nullptr) {
      delete script_instance_.cursor_animation_;
    }
    clear_has_script_instance();
  }
}
Script::Script(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serial.Script)
}
Script::Script(const Script& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  go_id_ = from.go_id_;
  clear_has_script_instance();
  switch (from.script_instance_case()) {
    case kPlayerAnimation: {
      _internal_mutable_player_animation()->::serial::PlayerAnimation::MergeFrom(from._internal_player_animation());
      break;
    }
    case kExampleCameraScript: {
      _internal_mutable_example_camera_script()->::serial::ExampleCameraScript::MergeFrom(from._internal_example_camera_script());
      break;
    }
    case kExampleClockedScript: {
      _internal_mutable_example_clocked_script()->::serial::ExampleClockedScript::MergeFrom(from._internal_example_clocked_script());
      break;
    }
    case kReloadSceneScript: {
      _internal_mutable_reload_scene_script()->::serial::ReloadSceneScript::MergeFrom(from._internal_reload_scene_script());
      break;
    }
    case kCameraScript: {
      _internal_mutable_camera_script()->::serial::CameraScript::MergeFrom(from._internal_camera_script());
      break;
    }
    case kButtonScript: {
      _internal_mutable_button_script()->::serial::ButtonScript::MergeFrom(from._internal_button_script());
      break;
    }
    case kClockedScript: {
      _internal_mutable_clocked_script()->::serial::ClockedScript::MergeFrom(from._internal_clocked_script());
      break;
    }
    case kExampleScript: {
      _internal_mutable_example_script()->::serial::ExampleScript::MergeFrom(from._internal_example_script());
      break;
    }
    case kStraightWeaponScript: {
      _internal_mutable_straight_weapon_script()->::serial::StraightWeaponScript::MergeFrom(from._internal_straight_weapon_script());
      break;
    }
    case kWeaponScript: {
      _internal_mutable_weapon_script()->::serial::WeaponScript::MergeFrom(from._internal_weapon_script());
      break;
    }
    case kBulletScript: {
      _internal_mutable_bullet_script()->::serial::BulletScript::MergeFrom(from._internal_bullet_script());
      break;
    }
    case kNetworkPlayerScript: {
      _internal_mutable_network_player_script()->::serial::NetworkPlayerScript::MergeFrom(from._internal_network_player_script());
      break;
    }
    case kCursorAnimation: {
      _internal_mutable_cursor_animation()->::serial::CursorAnimation::MergeFrom(from._internal_cursor_animation());
      break;
    }
    case SCRIPT_INSTANCE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:serial.Script)
}

inline void Script::SharedCtor() {
go_id_ = 0u;
clear_has_script_instance();
}

Script::~Script() {
  // @@protoc_insertion_point(destructor:serial.Script)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Script::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_script_instance()) {
    clear_script_instance();
  }
}

void Script::ArenaDtor(void* object) {
  Script* _this = reinterpret_cast< Script* >(object);
  (void)_this;
}
void Script::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Script::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Script::clear_script_instance() {
// @@protoc_insertion_point(one_of_clear_start:serial.Script)
  switch (script_instance_case()) {
    case kPlayerAnimation: {
      if (GetArenaForAllocation() == nullptr) {
        delete script_instance_.player_animation_;
      }
      break;
    }
    case kExampleCameraScript: {
      if (GetArenaForAllocation() == nullptr) {
        delete script_instance_.example_camera_script_;
      }
      break;
    }
    case kExampleClockedScript: {
      if (GetArenaForAllocation() == nullptr) {
        delete script_instance_.example_clocked_script_;
      }
      break;
    }
    case kReloadSceneScript: {
      if (GetArenaForAllocation() == nullptr) {
        delete script_instance_.reload_scene_script_;
      }
      break;
    }
    case kCameraScript: {
      if (GetArenaForAllocation() == nullptr) {
        delete script_instance_.camera_script_;
      }
      break;
    }
    case kButtonScript: {
      if (GetArenaForAllocation() == nullptr) {
        delete script_instance_.button_script_;
      }
      break;
    }
    case kClockedScript: {
      if (GetArenaForAllocation() == nullptr) {
        delete script_instance_.clocked_script_;
      }
      break;
    }
    case kExampleScript: {
      if (GetArenaForAllocation() == nullptr) {
        delete script_instance_.example_script_;
      }
      break;
    }
    case kStraightWeaponScript: {
      if (GetArenaForAllocation() == nullptr) {
        delete script_instance_.straight_weapon_script_;
      }
      break;
    }
    case kWeaponScript: {
      if (GetArenaForAllocation() == nullptr) {
        delete script_instance_.weapon_script_;
      }
      break;
    }
    case kBulletScript: {
      if (GetArenaForAllocation() == nullptr) {
        delete script_instance_.bullet_script_;
      }
      break;
    }
    case kNetworkPlayerScript: {
      if (GetArenaForAllocation() == nullptr) {
        delete script_instance_.network_player_script_;
      }
      break;
    }
    case kCursorAnimation: {
      if (GetArenaForAllocation() == nullptr) {
        delete script_instance_.cursor_animation_;
      }
      break;
    }
    case SCRIPT_INSTANCE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SCRIPT_INSTANCE_NOT_SET;
}


void Script::Clear() {
// @@protoc_insertion_point(message_clear_start:serial.Script)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  go_id_ = 0u;
  clear_script_instance();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Script::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .serial.PlayerAnimation player_animation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_player_animation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serial.ExampleCameraScript example_camera_script = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_example_camera_script(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serial.ExampleClockedScript example_clocked_script = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_example_clocked_script(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serial.ReloadSceneScript reload_scene_script = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_reload_scene_script(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serial.CameraScript camera_script = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_camera_script(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serial.ButtonScript button_script = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_button_script(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serial.ClockedScript clocked_script = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_clocked_script(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serial.ExampleScript example_script = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_example_script(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serial.StraightWeaponScript straight_weapon_script = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_straight_weapon_script(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serial.WeaponScript weapon_script = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_weapon_script(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serial.BulletScript bullet_script = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_bullet_script(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serial.NetworkPlayerScript network_player_script = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_network_player_script(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serial.CursorAnimation cursor_animation = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_cursor_animation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 go_id = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          go_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Script::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serial.Script)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .serial.PlayerAnimation player_animation = 1;
  if (_internal_has_player_animation()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::player_animation(this), target, stream);
  }

  // .serial.ExampleCameraScript example_camera_script = 2;
  if (_internal_has_example_camera_script()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::example_camera_script(this), target, stream);
  }

  // .serial.ExampleClockedScript example_clocked_script = 3;
  if (_internal_has_example_clocked_script()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::example_clocked_script(this), target, stream);
  }

  // .serial.ReloadSceneScript reload_scene_script = 4;
  if (_internal_has_reload_scene_script()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::reload_scene_script(this), target, stream);
  }

  // .serial.CameraScript camera_script = 5;
  if (_internal_has_camera_script()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::camera_script(this), target, stream);
  }

  // .serial.ButtonScript button_script = 6;
  if (_internal_has_button_script()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::button_script(this), target, stream);
  }

  // .serial.ClockedScript clocked_script = 7;
  if (_internal_has_clocked_script()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::clocked_script(this), target, stream);
  }

  // .serial.ExampleScript example_script = 8;
  if (_internal_has_example_script()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::example_script(this), target, stream);
  }

  // .serial.StraightWeaponScript straight_weapon_script = 9;
  if (_internal_has_straight_weapon_script()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::straight_weapon_script(this), target, stream);
  }

  // .serial.WeaponScript weapon_script = 10;
  if (_internal_has_weapon_script()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::weapon_script(this), target, stream);
  }

  // .serial.BulletScript bullet_script = 11;
  if (_internal_has_bullet_script()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::bullet_script(this), target, stream);
  }

  // .serial.NetworkPlayerScript network_player_script = 12;
  if (_internal_has_network_player_script()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::network_player_script(this), target, stream);
  }

  // .serial.CursorAnimation cursor_animation = 13;
  if (_internal_has_cursor_animation()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        13, _Internal::cursor_animation(this), target, stream);
  }

  // uint32 go_id = 14;
  if (this->_internal_go_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(14, this->_internal_go_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serial.Script)
  return target;
}

size_t Script::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serial.Script)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 go_id = 14;
  if (this->_internal_go_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_go_id());
  }

  switch (script_instance_case()) {
    // .serial.PlayerAnimation player_animation = 1;
    case kPlayerAnimation: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *script_instance_.player_animation_);
      break;
    }
    // .serial.ExampleCameraScript example_camera_script = 2;
    case kExampleCameraScript: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *script_instance_.example_camera_script_);
      break;
    }
    // .serial.ExampleClockedScript example_clocked_script = 3;
    case kExampleClockedScript: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *script_instance_.example_clocked_script_);
      break;
    }
    // .serial.ReloadSceneScript reload_scene_script = 4;
    case kReloadSceneScript: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *script_instance_.reload_scene_script_);
      break;
    }
    // .serial.CameraScript camera_script = 5;
    case kCameraScript: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *script_instance_.camera_script_);
      break;
    }
    // .serial.ButtonScript button_script = 6;
    case kButtonScript: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *script_instance_.button_script_);
      break;
    }
    // .serial.ClockedScript clocked_script = 7;
    case kClockedScript: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *script_instance_.clocked_script_);
      break;
    }
    // .serial.ExampleScript example_script = 8;
    case kExampleScript: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *script_instance_.example_script_);
      break;
    }
    // .serial.StraightWeaponScript straight_weapon_script = 9;
    case kStraightWeaponScript: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *script_instance_.straight_weapon_script_);
      break;
    }
    // .serial.WeaponScript weapon_script = 10;
    case kWeaponScript: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *script_instance_.weapon_script_);
      break;
    }
    // .serial.BulletScript bullet_script = 11;
    case kBulletScript: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *script_instance_.bullet_script_);
      break;
    }
    // .serial.NetworkPlayerScript network_player_script = 12;
    case kNetworkPlayerScript: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *script_instance_.network_player_script_);
      break;
    }
    // .serial.CursorAnimation cursor_animation = 13;
    case kCursorAnimation: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *script_instance_.cursor_animation_);
      break;
    }
    case SCRIPT_INSTANCE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Script::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Script::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Script::GetClassData() const { return &_class_data_; }

void Script::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Script *>(to)->MergeFrom(
      static_cast<const Script &>(from));
}


void Script::MergeFrom(const Script& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serial.Script)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_go_id() != 0) {
    _internal_set_go_id(from._internal_go_id());
  }
  switch (from.script_instance_case()) {
    case kPlayerAnimation: {
      _internal_mutable_player_animation()->::serial::PlayerAnimation::MergeFrom(from._internal_player_animation());
      break;
    }
    case kExampleCameraScript: {
      _internal_mutable_example_camera_script()->::serial::ExampleCameraScript::MergeFrom(from._internal_example_camera_script());
      break;
    }
    case kExampleClockedScript: {
      _internal_mutable_example_clocked_script()->::serial::ExampleClockedScript::MergeFrom(from._internal_example_clocked_script());
      break;
    }
    case kReloadSceneScript: {
      _internal_mutable_reload_scene_script()->::serial::ReloadSceneScript::MergeFrom(from._internal_reload_scene_script());
      break;
    }
    case kCameraScript: {
      _internal_mutable_camera_script()->::serial::CameraScript::MergeFrom(from._internal_camera_script());
      break;
    }
    case kButtonScript: {
      _internal_mutable_button_script()->::serial::ButtonScript::MergeFrom(from._internal_button_script());
      break;
    }
    case kClockedScript: {
      _internal_mutable_clocked_script()->::serial::ClockedScript::MergeFrom(from._internal_clocked_script());
      break;
    }
    case kExampleScript: {
      _internal_mutable_example_script()->::serial::ExampleScript::MergeFrom(from._internal_example_script());
      break;
    }
    case kStraightWeaponScript: {
      _internal_mutable_straight_weapon_script()->::serial::StraightWeaponScript::MergeFrom(from._internal_straight_weapon_script());
      break;
    }
    case kWeaponScript: {
      _internal_mutable_weapon_script()->::serial::WeaponScript::MergeFrom(from._internal_weapon_script());
      break;
    }
    case kBulletScript: {
      _internal_mutable_bullet_script()->::serial::BulletScript::MergeFrom(from._internal_bullet_script());
      break;
    }
    case kNetworkPlayerScript: {
      _internal_mutable_network_player_script()->::serial::NetworkPlayerScript::MergeFrom(from._internal_network_player_script());
      break;
    }
    case kCursorAnimation: {
      _internal_mutable_cursor_animation()->::serial::CursorAnimation::MergeFrom(from._internal_cursor_animation());
      break;
    }
    case SCRIPT_INSTANCE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Script::CopyFrom(const Script& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serial.Script)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Script::IsInitialized() const {
  return true;
}

void Script::InternalSwap(Script* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(go_id_, other->go_id_);
  swap(script_instance_, other->script_instance_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Script::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scene_2eproto_getter, &descriptor_table_scene_2eproto_once,
      file_level_metadata_scene_2eproto[3]);
}

// ===================================================================

class BasicGameObject::_Internal {
 public:
  static const ::serial::Sprite& sprite(const BasicGameObject* msg);
};

const ::serial::Sprite&
BasicGameObject::_Internal::sprite(const BasicGameObject* msg) {
  return *msg->sprite_;
}
BasicGameObject::BasicGameObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  children_objects_(arena),
  children_scripts_(arena),
  tags_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serial.BasicGameObject)
}
BasicGameObject::BasicGameObject(const BasicGameObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      children_objects_(from.children_objects_),
      children_scripts_(from.children_scripts_),
      tags_(from.tags_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_sprite()) {
    sprite_ = new ::serial::Sprite(*from.sprite_);
  } else {
    sprite_ = nullptr;
  }
  ::memcpy(&visible_, &from.visible_,
    static_cast<size_t>(reinterpret_cast<char*>(&id_) -
    reinterpret_cast<char*>(&visible_)) + sizeof(id_));
  // @@protoc_insertion_point(copy_constructor:serial.BasicGameObject)
}

inline void BasicGameObject::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sprite_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&id_) -
    reinterpret_cast<char*>(&sprite_)) + sizeof(id_));
}

BasicGameObject::~BasicGameObject() {
  // @@protoc_insertion_point(destructor:serial.BasicGameObject)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BasicGameObject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete sprite_;
}

void BasicGameObject::ArenaDtor(void* object) {
  BasicGameObject* _this = reinterpret_cast< BasicGameObject* >(object);
  (void)_this;
}
void BasicGameObject::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BasicGameObject::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BasicGameObject::Clear() {
// @@protoc_insertion_point(message_clear_start:serial.BasicGameObject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  children_objects_.Clear();
  children_scripts_.Clear();
  tags_.Clear();
  if (GetArenaForAllocation() == nullptr && sprite_ != nullptr) {
    delete sprite_;
  }
  sprite_ = nullptr;
  ::memset(&visible_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&id_) -
      reinterpret_cast<char*>(&visible_)) + sizeof(id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BasicGameObject::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .serial.GameObject children_objects = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_children_objects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .serial.Script children_scripts = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_children_scripts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string tags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_tags();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "serial.BasicGameObject.tags"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .serial.Sprite sprite = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_sprite(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool visible = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          visible_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serial.Box2DType box2d_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_box2d_type(static_cast<::serial::Box2DType>(val));
        } else
          goto handle_unusual;
        continue;
      // .serial.RenderLayer render_layer = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_render_layer(static_cast<::serial::RenderLayer>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BasicGameObject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serial.BasicGameObject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .serial.GameObject children_objects = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_children_objects_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_children_objects(i), target, stream);
  }

  // repeated .serial.Script children_scripts = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_children_scripts_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_children_scripts(i), target, stream);
  }

  // repeated string tags = 3;
  for (int i = 0, n = this->_internal_tags_size(); i < n; i++) {
    const auto& s = this->_internal_tags(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "serial.BasicGameObject.tags");
    target = stream->WriteString(3, s, target);
  }

  // .serial.Sprite sprite = 4;
  if (this->_internal_has_sprite()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::sprite(this), target, stream);
  }

  // bool visible = 5;
  if (this->_internal_visible() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_visible(), target);
  }

  // .serial.Box2DType box2d_type = 6;
  if (this->_internal_box2d_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_box2d_type(), target);
  }

  // .serial.RenderLayer render_layer = 7;
  if (this->_internal_render_layer() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_render_layer(), target);
  }

  // uint32 id = 8;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serial.BasicGameObject)
  return target;
}

size_t BasicGameObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serial.BasicGameObject)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .serial.GameObject children_objects = 1;
  total_size += 1UL * this->_internal_children_objects_size();
  for (const auto& msg : this->children_objects_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .serial.Script children_scripts = 2;
  total_size += 1UL * this->_internal_children_scripts_size();
  for (const auto& msg : this->children_scripts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string tags = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(tags_.size());
  for (int i = 0, n = tags_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      tags_.Get(i));
  }

  // .serial.Sprite sprite = 4;
  if (this->_internal_has_sprite()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sprite_);
  }

  // bool visible = 5;
  if (this->_internal_visible() != 0) {
    total_size += 1 + 1;
  }

  // .serial.Box2DType box2d_type = 6;
  if (this->_internal_box2d_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_box2d_type());
  }

  // .serial.RenderLayer render_layer = 7;
  if (this->_internal_render_layer() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_render_layer());
  }

  // uint32 id = 8;
  if (this->_internal_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BasicGameObject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BasicGameObject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BasicGameObject::GetClassData() const { return &_class_data_; }

void BasicGameObject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BasicGameObject *>(to)->MergeFrom(
      static_cast<const BasicGameObject &>(from));
}


void BasicGameObject::MergeFrom(const BasicGameObject& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serial.BasicGameObject)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  children_objects_.MergeFrom(from.children_objects_);
  children_scripts_.MergeFrom(from.children_scripts_);
  tags_.MergeFrom(from.tags_);
  if (from._internal_has_sprite()) {
    _internal_mutable_sprite()->::serial::Sprite::MergeFrom(from._internal_sprite());
  }
  if (from._internal_visible() != 0) {
    _internal_set_visible(from._internal_visible());
  }
  if (from._internal_box2d_type() != 0) {
    _internal_set_box2d_type(from._internal_box2d_type());
  }
  if (from._internal_render_layer() != 0) {
    _internal_set_render_layer(from._internal_render_layer());
  }
  if (from._internal_id() != 0) {
    _internal_set_id(from._internal_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BasicGameObject::CopyFrom(const BasicGameObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serial.BasicGameObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BasicGameObject::IsInitialized() const {
  return true;
}

void BasicGameObject::InternalSwap(BasicGameObject* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  children_objects_.InternalSwap(&other->children_objects_);
  children_scripts_.InternalSwap(&other->children_scripts_);
  tags_.InternalSwap(&other->tags_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BasicGameObject, id_)
      + sizeof(BasicGameObject::id_)
      - PROTOBUF_FIELD_OFFSET(BasicGameObject, sprite_)>(
          reinterpret_cast<char*>(&sprite_),
          reinterpret_cast<char*>(&other->sprite_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BasicGameObject::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scene_2eproto_getter, &descriptor_table_scene_2eproto_once,
      file_level_metadata_scene_2eproto[4]);
}

// ===================================================================

class Sprite_Scale::_Internal {
 public:
};

Sprite_Scale::Sprite_Scale(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serial.Sprite.Scale)
}
Sprite_Scale::Sprite_Scale(const Sprite_Scale& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&scale_x_, &from.scale_x_,
    static_cast<size_t>(reinterpret_cast<char*>(&scale_y_) -
    reinterpret_cast<char*>(&scale_x_)) + sizeof(scale_y_));
  // @@protoc_insertion_point(copy_constructor:serial.Sprite.Scale)
}

inline void Sprite_Scale::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&scale_x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&scale_y_) -
    reinterpret_cast<char*>(&scale_x_)) + sizeof(scale_y_));
}

Sprite_Scale::~Sprite_Scale() {
  // @@protoc_insertion_point(destructor:serial.Sprite.Scale)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Sprite_Scale::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Sprite_Scale::ArenaDtor(void* object) {
  Sprite_Scale* _this = reinterpret_cast< Sprite_Scale* >(object);
  (void)_this;
}
void Sprite_Scale::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Sprite_Scale::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Sprite_Scale::Clear() {
// @@protoc_insertion_point(message_clear_start:serial.Sprite.Scale)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&scale_x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&scale_y_) -
      reinterpret_cast<char*>(&scale_x_)) + sizeof(scale_y_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Sprite_Scale::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float scale_x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          scale_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float scale_y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          scale_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Sprite_Scale::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serial.Sprite.Scale)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float scale_x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale_x = this->_internal_scale_x();
  uint32_t raw_scale_x;
  memcpy(&raw_scale_x, &tmp_scale_x, sizeof(tmp_scale_x));
  if (raw_scale_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_scale_x(), target);
  }

  // float scale_y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale_y = this->_internal_scale_y();
  uint32_t raw_scale_y;
  memcpy(&raw_scale_y, &tmp_scale_y, sizeof(tmp_scale_y));
  if (raw_scale_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_scale_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serial.Sprite.Scale)
  return target;
}

size_t Sprite_Scale::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serial.Sprite.Scale)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float scale_x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale_x = this->_internal_scale_x();
  uint32_t raw_scale_x;
  memcpy(&raw_scale_x, &tmp_scale_x, sizeof(tmp_scale_x));
  if (raw_scale_x != 0) {
    total_size += 1 + 4;
  }

  // float scale_y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale_y = this->_internal_scale_y();
  uint32_t raw_scale_y;
  memcpy(&raw_scale_y, &tmp_scale_y, sizeof(tmp_scale_y));
  if (raw_scale_y != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Sprite_Scale::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Sprite_Scale::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Sprite_Scale::GetClassData() const { return &_class_data_; }

void Sprite_Scale::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Sprite_Scale *>(to)->MergeFrom(
      static_cast<const Sprite_Scale &>(from));
}


void Sprite_Scale::MergeFrom(const Sprite_Scale& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serial.Sprite.Scale)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale_x = from._internal_scale_x();
  uint32_t raw_scale_x;
  memcpy(&raw_scale_x, &tmp_scale_x, sizeof(tmp_scale_x));
  if (raw_scale_x != 0) {
    _internal_set_scale_x(from._internal_scale_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale_y = from._internal_scale_y();
  uint32_t raw_scale_y;
  memcpy(&raw_scale_y, &tmp_scale_y, sizeof(tmp_scale_y));
  if (raw_scale_y != 0) {
    _internal_set_scale_y(from._internal_scale_y());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Sprite_Scale::CopyFrom(const Sprite_Scale& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serial.Sprite.Scale)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sprite_Scale::IsInitialized() const {
  return true;
}

void Sprite_Scale::InternalSwap(Sprite_Scale* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Sprite_Scale, scale_y_)
      + sizeof(Sprite_Scale::scale_y_)
      - PROTOBUF_FIELD_OFFSET(Sprite_Scale, scale_x_)>(
          reinterpret_cast<char*>(&scale_x_),
          reinterpret_cast<char*>(&other->scale_x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Sprite_Scale::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scene_2eproto_getter, &descriptor_table_scene_2eproto_once,
      file_level_metadata_scene_2eproto[5]);
}

// ===================================================================

class Sprite::_Internal {
 public:
  static const ::serial::Vector2f& position(const Sprite* msg);
  static const ::serial::Sprite_Scale& scale(const Sprite* msg);
};

const ::serial::Vector2f&
Sprite::_Internal::position(const Sprite* msg) {
  return *msg->position_;
}
const ::serial::Sprite_Scale&
Sprite::_Internal::scale(const Sprite* msg) {
  return *msg->scale_;
}
void Sprite::clear_position() {
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
Sprite::Sprite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serial.Sprite)
}
Sprite::Sprite(const Sprite& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  texture_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    texture_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_texture_path().empty()) {
    texture_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_texture_path(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_position()) {
    position_ = new ::serial::Vector2f(*from.position_);
  } else {
    position_ = nullptr;
  }
  if (from._internal_has_scale()) {
    scale_ = new ::serial::Sprite_Scale(*from.scale_);
  } else {
    scale_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:serial.Sprite)
}

inline void Sprite::SharedCtor() {
texture_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  texture_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&position_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&scale_) -
    reinterpret_cast<char*>(&position_)) + sizeof(scale_));
}

Sprite::~Sprite() {
  // @@protoc_insertion_point(destructor:serial.Sprite)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Sprite::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  texture_path_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete position_;
  if (this != internal_default_instance()) delete scale_;
}

void Sprite::ArenaDtor(void* object) {
  Sprite* _this = reinterpret_cast< Sprite* >(object);
  (void)_this;
}
void Sprite::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Sprite::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Sprite::Clear() {
// @@protoc_insertion_point(message_clear_start:serial.Sprite)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  texture_path_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
  if (GetArenaForAllocation() == nullptr && scale_ != nullptr) {
    delete scale_;
  }
  scale_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Sprite::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string texture_path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_texture_path();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "serial.Sprite.texture_path"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serial.Vector2f position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serial.Sprite.Scale scale = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_scale(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Sprite::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serial.Sprite)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string texture_path = 1;
  if (!this->_internal_texture_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_texture_path().data(), static_cast<int>(this->_internal_texture_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "serial.Sprite.texture_path");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_texture_path(), target);
  }

  // .serial.Vector2f position = 2;
  if (this->_internal_has_position()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::position(this), target, stream);
  }

  // .serial.Sprite.Scale scale = 5;
  if (this->_internal_has_scale()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::scale(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serial.Sprite)
  return target;
}

size_t Sprite::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serial.Sprite)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string texture_path = 1;
  if (!this->_internal_texture_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_texture_path());
  }

  // .serial.Vector2f position = 2;
  if (this->_internal_has_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *position_);
  }

  // .serial.Sprite.Scale scale = 5;
  if (this->_internal_has_scale()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *scale_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Sprite::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Sprite::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Sprite::GetClassData() const { return &_class_data_; }

void Sprite::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Sprite *>(to)->MergeFrom(
      static_cast<const Sprite &>(from));
}


void Sprite::MergeFrom(const Sprite& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serial.Sprite)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_texture_path().empty()) {
    _internal_set_texture_path(from._internal_texture_path());
  }
  if (from._internal_has_position()) {
    _internal_mutable_position()->::serial::Vector2f::MergeFrom(from._internal_position());
  }
  if (from._internal_has_scale()) {
    _internal_mutable_scale()->::serial::Sprite_Scale::MergeFrom(from._internal_scale());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Sprite::CopyFrom(const Sprite& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serial.Sprite)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sprite::IsInitialized() const {
  return true;
}

void Sprite::InternalSwap(Sprite* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &texture_path_, lhs_arena,
      &other->texture_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Sprite, scale_)
      + sizeof(Sprite::scale_)
      - PROTOBUF_FIELD_OFFSET(Sprite, position_)>(
          reinterpret_cast<char*>(&position_),
          reinterpret_cast<char*>(&other->position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Sprite::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scene_2eproto_getter, &descriptor_table_scene_2eproto_once,
      file_level_metadata_scene_2eproto[6]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace serial
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::serial::Scene* Arena::CreateMaybeMessage< ::serial::Scene >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serial::Scene >(arena);
}
template<> PROTOBUF_NOINLINE ::serial::Camera* Arena::CreateMaybeMessage< ::serial::Camera >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serial::Camera >(arena);
}
template<> PROTOBUF_NOINLINE ::serial::GameObject* Arena::CreateMaybeMessage< ::serial::GameObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serial::GameObject >(arena);
}
template<> PROTOBUF_NOINLINE ::serial::Script* Arena::CreateMaybeMessage< ::serial::Script >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serial::Script >(arena);
}
template<> PROTOBUF_NOINLINE ::serial::BasicGameObject* Arena::CreateMaybeMessage< ::serial::BasicGameObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serial::BasicGameObject >(arena);
}
template<> PROTOBUF_NOINLINE ::serial::Sprite_Scale* Arena::CreateMaybeMessage< ::serial::Sprite_Scale >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serial::Sprite_Scale >(arena);
}
template<> PROTOBUF_NOINLINE ::serial::Sprite* Arena::CreateMaybeMessage< ::serial::Sprite >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serial::Sprite >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
